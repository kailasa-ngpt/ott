"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mpd-parser";
exports.ids = ["vendor-chunks/mpd-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/mpd-parser/dist/mpd-parser.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/mpd-parser/dist/mpd-parser.es.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   addSidxSegmentsToPlaylist: () => (/* binding */ addSidxSegmentsToPlaylist$1),\n/* harmony export */   generateSidxKey: () => (/* binding */ generateSidxKey),\n/* harmony export */   inheritAttributes: () => (/* binding */ inheritAttributes),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseUTCTiming: () => (/* binding */ parseUTCTiming),\n/* harmony export */   stringToMpdXml: () => (/* binding */ stringToMpdXml),\n/* harmony export */   toM3u8: () => (/* binding */ toM3u8),\n/* harmony export */   toPlaylists: () => (/* binding */ toPlaylists)\n/* harmony export */ });\n/* harmony import */ var _videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @videojs/vhs-utils/es/resolve-url */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/resolve-url.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _videojs_vhs_utils_es_media_groups__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @videojs/vhs-utils/es/media-groups */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/media-groups.js\");\n/* harmony import */ var _videojs_vhs_utils_es_decode_b64_to_uint8_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @videojs/vhs-utils/es/decode-b64-to-uint8-array */ \"(ssr)/./node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js\");\n/* harmony import */ var _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @xmldom/xmldom */ \"(ssr)/./node_modules/@xmldom/xmldom/lib/index.js\");\n/*! @name mpd-parser @version 1.3.1 @license Apache-2.0 */\n\n\n\n\n\n\nvar version = \"1.3.1\";\n\nconst isObject = obj => {\n  return !!obj && typeof obj === 'object';\n};\n\nconst merge = (...objects) => {\n  return objects.reduce((result, source) => {\n    if (typeof source !== 'object') {\n      return result;\n    }\n\n    Object.keys(source).forEach(key => {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nconst values = o => Object.keys(o).map(k => o[k]);\n\nconst range = (start, end) => {\n  const result = [];\n\n  for (let i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\nconst flatten = lists => lists.reduce((x, y) => x.concat(y), []);\nconst from = list => {\n  if (!list.length) {\n    return [];\n  }\n\n  const result = [];\n\n  for (let i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\nconst findIndexes = (l, key) => l.reduce((a, e, i) => {\n  if (e[key]) {\n    a.push(i);\n  }\n\n  return a;\n}, []);\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\nconst union = (lists, keyFunction) => {\n  return values(lists.reduce((acc, list) => {\n    list.forEach(el => {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  INVALID_NUMBER_OF_CONTENT_STEERING: 'INVALID_NUMBER_OF_CONTENT_STEERING',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nconst urlTypeToSegment = ({\n  baseUrl = '',\n  source = '',\n  range = '',\n  indexRange = ''\n}) => {\n  const segment = {\n    uri: source,\n    resolvedUri: (0,_videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    const rangeStr = range ? range : indexRange;\n    const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    let startRange = (global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt) ? global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    let endRange = (global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt) ? global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n\n    let length;\n\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(endRange) - global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(startRange) + global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n\n    segment.byterange = {\n      length,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\nconst byteRangeToString = byterange => {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  let endRange;\n\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(byterange.offset) + global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(byterange.length) - global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n\n  return `${byterange.offset}-${endRange}`;\n};\n\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\nconst parseEndNumber = endNumber => {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n\n  if (isNaN(endNumber)) {\n    return null;\n  }\n\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nconst segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static(attributes) {\n    const {\n      duration,\n      timescale = 1,\n      sourceDuration,\n      periodDuration\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber);\n    const segmentDuration = duration / timescale;\n\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic(attributes) {\n    const {\n      NOW,\n      clientOffset,\n      availabilityStartTime,\n      timescale = 1,\n      duration,\n      periodStart = 0,\n      minimumUpdatePeriod = 0,\n      timeShiftBufferDepth = Infinity\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    const periodEndWC = now + minimumUpdatePeriod;\n    const periodDuration = periodEndWC - periodStartWC;\n    const segmentCount = Math.ceil(periodDuration * timescale / duration);\n    const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nconst toSegments = attributes => number => {\n  const {\n    duration,\n    timescale = 1,\n    periodStart,\n    startNumber = 1\n  } = attributes;\n  return {\n    number: startNumber + number,\n    duration: duration / timescale,\n    timeline: periodStart,\n    time: number * duration\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseByDuration = attributes => {\n  const {\n    type,\n    duration,\n    timescale = 1,\n    periodDuration,\n    sourceDuration\n  } = attributes;\n  const {\n    start,\n    end\n  } = segmentRange[type](attributes);\n  const segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    const index = segments.length - 1; // section is either a period or the full source\n\n    const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nconst segmentsFromBase = attributes => {\n  const {\n    baseUrl,\n    initialization = {},\n    sourceDuration,\n    indexRange = '',\n    periodStart,\n    presentationTime,\n    number = 0,\n    duration\n  } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: baseUrl,\n    indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    const segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\nconst addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n  // Retain init segment information\n  const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  const timeline = playlist.timeline || 0;\n  const sidxByteRange = playlist.sidx.byterange;\n  const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n  const segments = [];\n  const type = playlist.endList ? 'static' : 'dynamic';\n  const periodStart = playlist.sidx.timeline;\n  let presentationTime = periodStart;\n  let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  let startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n\n  for (let i = 0; i < mediaReferences.length; i++) {\n    const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    const duration = reference.subsegmentDuration; // should be an inclusive range\n\n    let endIndex; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(size) - global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n\n    const indexRange = `${startIndex}-${endIndex}`;\n    const attributes = {\n      baseUrl,\n      timescale,\n      timeline,\n      periodStart,\n      presentationTime,\n      number,\n      duration,\n      sourceDuration,\n      indexRange,\n      type\n    };\n    const segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n\n    if (typeof startIndex === 'bigint') {\n      startIndex += global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(size);\n    } else {\n      startIndex += size;\n    }\n\n    presentationTime += duration / timescale;\n    number++;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nconst SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nconst TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nconst getUniqueTimelineStarts = timelineStarts => {\n  return union(timelineStarts, ({\n    timeline\n  }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\nconst findPlaylistWithName = (playlists, name) => {\n  for (let i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\nconst getMediaGroupPlaylists = manifest => {\n  let mediaGroupPlaylists = [];\n  (0,_videojs_vhs_utils_es_media_groups__WEBPACK_IMPORTED_MODULE_2__.forEachMediaGroup)(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\nconst updateMediaSequenceForPlaylist = ({\n  playlist,\n  mediaSequence\n}) => {\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach((segment, index) => {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\nconst updateSequenceNumbers = ({\n  oldPlaylists,\n  newPlaylists,\n  timelineStarts\n}) => {\n  newPlaylists.forEach(playlist => {\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n\n    const firstNewSegment = playlist.segments[0];\n    const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n\n    const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n\n    updateMediaSequenceForPlaylist({\n      playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\nconst positionManifestOnTimeline = ({\n  oldManifest,\n  newManifest\n}) => {\n  // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n  const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists,\n    newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\n\nconst generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n\nconst mergeDiscontiguousPlaylists = playlists => {\n  // Break out playlists into groups based on their baseUrl\n  const playlistsByBaseUrl = playlists.reduce(function (acc, cur) {\n    if (!acc[cur.attributes.baseUrl]) {\n      acc[cur.attributes.baseUrl] = [];\n    }\n\n    acc[cur.attributes.baseUrl].push(cur);\n    return acc;\n  }, {});\n  let allPlaylists = [];\n  Object.values(playlistsByBaseUrl).forEach(playlistGroup => {\n    const mergedPlaylists = values(playlistGroup.reduce((acc, playlist) => {\n      // assuming playlist IDs are the same across periods\n      // TODO: handle multiperiod where representation sets are not the same\n      // across periods\n      const name = playlist.attributes.id + (playlist.attributes.lang || '');\n\n      if (!acc[name]) {\n        // First Period\n        acc[name] = playlist;\n        acc[name].attributes.timelineStarts = [];\n      } else {\n        // Subsequent Periods\n        if (playlist.segments) {\n          // first segment of subsequent periods signal a discontinuity\n          if (playlist.segments[0]) {\n            playlist.segments[0].discontinuity = true;\n          }\n\n          acc[name].segments.push(...playlist.segments);\n        } // bubble up contentProtection, this assumes all DRM content\n        // has the same contentProtection\n\n\n        if (playlist.attributes.contentProtection) {\n          acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n        }\n      }\n\n      acc[name].attributes.timelineStarts.push({\n        // Although they represent the same number, it's important to have both to make it\n        // compatible with HLS potentially having a similar attribute.\n        start: playlist.attributes.periodStart,\n        timeline: playlist.attributes.periodStart\n      });\n      return acc;\n    }, {}));\n    allPlaylists = allPlaylists.concat(mergedPlaylists);\n  });\n  return allPlaylists.map(playlist => {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\n\nconst addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n  const sidxKey = generateSidxKey(playlist.sidx);\n  const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n\n  return playlist;\n};\nconst addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (const i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n\n  return playlists;\n};\nconst formatAudioPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  mediaSequence,\n  discontinuitySequence,\n  discontinuityStarts\n}, isAudioOnly) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuitySequence,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n\n  return playlist;\n};\nconst formatVttPlaylist = ({\n  attributes,\n  segments,\n  mediaSequence,\n  discontinuityStarts,\n  discontinuitySequence\n}) => {\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  const m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth,\n    ['PROGRAM-ID']: 1\n  };\n\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n\n  const vttPlaylist = {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts,\n    discontinuitySequence,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.serviceLocation) {\n    vttPlaylist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  return vttPlaylist;\n};\nconst organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {\n  let mainPlaylist;\n  const formattedPlaylists = playlists.reduce((a, playlist) => {\n    const role = playlist.attributes.role && playlist.attributes.role.value || '';\n    const language = playlist.attributes.lang || '';\n    let label = playlist.attributes.label || 'main';\n\n    if (language && !playlist.attributes.label) {\n      const roleLabel = role ? ` (${role})` : '';\n      label = `${playlist.attributes.lang}${roleLabel}`;\n    }\n\n    if (!a[label]) {\n      a[label] = {\n        language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    const firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\nconst organizeVttPlaylists = (playlists, sidxMapping = {}) => {\n  return playlists.reduce((a, playlist) => {\n    const label = playlist.attributes.label || playlist.attributes.lang || 'text';\n    const language = playlist.attributes.lang || 'und';\n\n    if (!a[label]) {\n      a[label] = {\n        language,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\n\nconst organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n  if (!svc) {\n    return svcObj;\n  }\n\n  svc.forEach(service => {\n    const {\n      channel,\n      language\n    } = service;\n    svcObj[language] = {\n      autoselect: false,\n      default: false,\n      instreamId: channel,\n      language\n    };\n\n    if (service.hasOwnProperty('aspectRatio')) {\n      svcObj[language].aspectRatio = service.aspectRatio;\n    }\n\n    if (service.hasOwnProperty('easyReader')) {\n      svcObj[language].easyReader = service.easyReader;\n    }\n\n    if (service.hasOwnProperty('3D')) {\n      svcObj[language]['3D'] = service['3D'];\n    }\n  });\n  return svcObj;\n}, {});\n\nconst formatVideoPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  discontinuityStarts\n}) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments\n  };\n\n  if (attributes.frameRate) {\n    playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n  }\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nconst videoOnly = ({\n  attributes\n}) => attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n\nconst audioOnly = ({\n  attributes\n}) => attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n\nconst vttOnly = ({\n  attributes\n}) => attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\n\nconst addMediaSequenceValues = (playlists, timelineStarts) => {\n  // increment all segments sequentially\n  playlists.forEach(playlist => {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    });\n\n    if (!playlist.segments) {\n      return;\n    }\n\n    playlist.segments.forEach((segment, index) => {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\nconst flattenMediaGroupPlaylists = mediaGroupObject => {\n  if (!mediaGroupObject) {\n    return [];\n  }\n\n  return Object.keys(mediaGroupObject).reduce((acc, label) => {\n    const labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\nconst toM3u8 = ({\n  dashPlaylists,\n  locations,\n  contentSteering,\n  sidxMapping = {},\n  previousManifest,\n  eventStream\n}) => {\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n\n  const {\n    sourceDuration: duration,\n    type,\n    suggestedPresentationDelay,\n    minimumUpdatePeriod\n  } = dashPlaylists[0].attributes;\n  const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n  const manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: {\n      AUDIO: {},\n      VIDEO: {},\n      ['CLOSED-CAPTIONS']: {},\n      SUBTITLES: {}\n    },\n    uri: '',\n    duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n\n  if (locations) {\n    manifest.locations = locations;\n  }\n\n  if (contentSteering) {\n    manifest.contentSteering = contentSteering;\n  }\n\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n\n  if (eventStream && eventStream.length > 0) {\n    manifest.eventStream = eventStream;\n  }\n\n  const isAudioOnly = manifest.playlists.length === 0;\n  const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  const playlistTimelineStarts = formattedPlaylists.map(({\n    timelineStarts\n  }) => timelineStarts);\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n\n  return manifest;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nconst getLiveRValue = (attributes, time, duration) => {\n  const {\n    NOW,\n    clientOffset,\n    availabilityStartTime,\n    timescale = 1,\n    periodStart = 0,\n    minimumUpdatePeriod = 0\n  } = attributes;\n  const now = (NOW + clientOffset) / 1000;\n  const periodStartWC = availabilityStartTime + periodStart;\n  const periodEndWC = now + minimumUpdatePeriod;\n  const periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nconst parseByTimeline = (attributes, segmentTimeline) => {\n  const {\n    type,\n    minimumUpdatePeriod = 0,\n    media = '',\n    sourceDuration,\n    timescale = 1,\n    startNumber = 1,\n    periodStart: timeline\n  } = attributes;\n  const segments = [];\n  let time = -1;\n\n  for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    const S = segmentTimeline[sIndex];\n    const duration = S.d;\n    const repeat = S.r || 0;\n    const segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    let count;\n\n    if (repeat < 0) {\n      const nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    const end = startNumber + segments.length + count;\n    let number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number,\n        duration: duration / timescale,\n        time,\n        timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nconst identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nconst identifierReplacement = values => (match, identifier, format, width) => {\n  if (match === '$$') {\n    // escape sequence\n    return '$';\n  }\n\n  if (typeof values[identifier] === 'undefined') {\n    return match;\n  }\n\n  const value = '' + values[identifier];\n\n  if (identifier === 'RepresentationID') {\n    // Format tag shall not be present with RepresentationID\n    return value;\n  }\n\n  if (!format) {\n    width = 1;\n  } else {\n    width = parseInt(width, 10);\n  }\n\n  if (value.length >= width) {\n    return value;\n  }\n\n  return `${new Array(width - value.length + 1).join('0')}${value}`;\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nconst constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseTemplateInfo = (attributes, segmentTimeline) => {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nconst segmentsFromTemplate = (attributes, segmentTimeline) => {\n  const templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  const {\n    initialization = {\n      sourceURL: '',\n      range: ''\n    }\n  } = attributes;\n  const mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  const segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(segment => {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    const presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    const map = {\n      uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: (0,_videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime\n    };\n    return map;\n  });\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nconst SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n  const {\n    baseUrl,\n    initialization = {}\n  } = attributes;\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nconst segmentsFromList = (attributes, segmentTimeline) => {\n  const {\n    duration,\n    segmentUrls = [],\n    periodStart\n  } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n  let segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  const segments = segmentTimeInfo.map((segmentTime, index) => {\n    if (segmentUrlMap[index]) {\n      const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(segment => segment);\n  return segments;\n};\n\nconst generateSegments = ({\n  attributes,\n  segmentInfo\n}) => {\n  let segmentAttributes;\n  let segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  const segmentsInfo = {\n    attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    const {\n      duration,\n      timescale = 1\n    } = segmentAttributes;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce((max, segment) => {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\nconst toPlaylists = representations => representations.map(generateSegments);\n\nconst findChildren = (element, name) => from(element.childNodes).filter(({\n  tagName\n}) => tagName === name);\nconst getContent = element => element.textContent.trim();\n\n/**\n * Converts the provided string that may contain a division operation to a number.\n *\n * @param {string} value - the provided string value\n *\n * @return {number} the parsed string value\n */\nconst parseDivisionValue = value => {\n  return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n};\n\nconst parseDuration = str => {\n  const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  const SECONDS_IN_DAY = 24 * 60 * 60;\n  const SECONDS_IN_HOUR = 60 * 60;\n  const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  const match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  const [year, month, day, hour, minute, second] = match.slice(1);\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nconst parseDate = str => {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nconst parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type(value) {\n    return value;\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the frame rate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed frame rate\n   */\n  frameRate(value) {\n    return parseDivisionValue(value);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration(value) {\n    const parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTime.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTime\n   */\n  presentationTime(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT(value) {\n    return value;\n  }\n\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nconst parseAttributes = el => {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce((a, e) => {\n    const parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nconst keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime',\n  // ISO_IEC 23009-1_2022 5.8.5.2.2 The mp4 Protection Scheme\n  'urn:mpeg:dash:mp4protection:2011': 'mp4protection'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {Object[]} references\n *        List of objects containing the reference URL as well as its attributes\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {Object[]}\n *         List of objects with resolved urls and attributes\n */\n\nconst buildBaseUrls = (references, baseUrlElements) => {\n  if (!baseUrlElements.length) {\n    return references;\n  }\n\n  return flatten(references.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      const initialBaseUrl = getContent(baseUrlElement);\n      const resolvedBaseUrl = (0,_videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(reference.baseUrl, initialBaseUrl);\n      const finalBaseUrl = merge(parseAttributes(baseUrlElement), {\n        baseUrl: resolvedBaseUrl\n      }); // If the URL is resolved, we want to get the serviceLocation from the reference\n      // assuming there is no serviceLocation on the initialBaseUrl\n\n      if (resolvedBaseUrl !== initialBaseUrl && !finalBaseUrl.serviceLocation && reference.serviceLocation) {\n        finalBaseUrl.serviceLocation = reference.serviceLocation;\n      }\n\n      return finalBaseUrl;\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nconst getSegmentInformation = adaptationSet => {\n  const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge({\n    tag: 'SegmentURL'\n  }, parseAttributes(s)));\n  const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  const segmentTimelineParentNode = segmentList || segmentTemplate;\n  const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  const template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  const segmentInfo = {\n    template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(key => {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {Object[]} adaptationSetBaseUrls\n *        List of objects containing resolved base URLs and attributes\n *        inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nconst inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n  const repBaseUrlElements = findChildren(representation, 'BaseURL');\n  const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n  const attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n  const representationSegmentInfo = getSegmentInformation(representation);\n  return repBaseUrls.map(baseUrl => {\n    return {\n      segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n      attributes: merge(attributes, baseUrl)\n    };\n  });\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nconst generateKeySystemInformation = contentProtectionNodes => {\n  return contentProtectionNodes.reduce((acc, node) => {\n    const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n\n    const keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes\n      };\n      const psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        const pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && (0,_videojs_vhs_utils_es_decode_b64_to_uint8_array__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(pssh);\n      }\n    }\n\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\n\nconst parseCaptionServiceMetadata = service => {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      let channel;\n      let language; // default language to value\n\n      language = value;\n\n      if (/^CC\\d=/.test(value)) {\n        [channel, language] = value.split('=');\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n\n      return {\n        channel,\n        language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      const flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n\n      if (/=/.test(value)) {\n        const [channel, opts = ''] = value.split('=');\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(opt => {\n          const [name, val] = opt.split(':');\n\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n\n      return flags;\n    });\n  }\n};\n/**\n * A map callback that will parse all event stream data for a collection of periods\n * DASH ISO_IEC_23009 5.10.2.2\n * https://dashif-documents.azurewebsites.net/Events/master/event.html#mpd-event-timing\n *\n * @param {PeriodInformation} period object containing necessary period information\n * @return a collection of parsed eventstream event objects\n */\n\nconst toEventStream = period => {\n  // get and flatten all EventStreams tags and parse attributes and children\n  return flatten(findChildren(period.node, 'EventStream').map(eventStream => {\n    const eventStreamAttributes = parseAttributes(eventStream);\n    const schemeIdUri = eventStreamAttributes.schemeIdUri; // find all Events per EventStream tag and map to return objects\n\n    return findChildren(eventStream, 'Event').map(event => {\n      const eventAttributes = parseAttributes(event);\n      const presentationTime = eventAttributes.presentationTime || 0;\n      const timescale = eventStreamAttributes.timescale || 1;\n      const duration = eventAttributes.duration || 0;\n      const start = presentationTime / timescale + period.attributes.start;\n      return {\n        schemeIdUri,\n        value: eventStreamAttributes.value,\n        id: eventAttributes.id,\n        start,\n        end: start + duration / timescale,\n        messageData: getContent(event) || eventAttributes.messageData,\n        contentEncoding: eventStreamAttributes.contentEncoding,\n        presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0\n      };\n    });\n  }));\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {Object[]} periodBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\nconst toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n  const adaptationSetAttributes = parseAttributes(adaptationSet);\n  const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n  const role = findChildren(adaptationSet, 'Role')[0];\n  const roleAttributes = {\n    role: parseAttributes(role)\n  };\n  let attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n  const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n  const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n\n  if (captionServices) {\n    attrs = merge(attrs, {\n      captionServices\n    });\n  }\n\n  const label = findChildren(adaptationSet, 'Label')[0];\n\n  if (label && label.childNodes.length) {\n    const labelVal = label.childNodes[0].nodeValue.trim();\n    attrs = merge(attrs, {\n      label: labelVal\n    });\n  }\n\n  const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n  if (Object.keys(contentProtection).length) {\n    attrs = merge(attrs, {\n      contentProtection\n    });\n  }\n\n  const segmentInfo = getSegmentInformation(adaptationSet);\n  const representations = findChildren(adaptationSet, 'Representation');\n  const adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n  return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n  * @param {Object[]} mpdBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nconst toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n  const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n  const periodAttributes = merge(mpdAttributes, {\n    periodStart: period.attributes.start\n  });\n\n  if (typeof period.attributes.duration === 'number') {\n    periodAttributes.periodDuration = period.attributes.duration;\n  }\n\n  const adaptationSets = findChildren(period.node, 'AdaptationSet');\n  const periodSegmentInfo = getSegmentInformation(period.node);\n  return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n};\n/**\n * Tranforms an array of content steering nodes into an object\n * containing CDN content steering information from the MPD manifest.\n *\n * For more information on the DASH spec for Content Steering parsing, see:\n * https://dashif.org/docs/DASH-IF-CTS-00XX-Content-Steering-Community-Review.pdf\n *\n * @param {Node[]} contentSteeringNodes\n *        Content steering nodes\n * @param {Function} eventHandler\n *        The event handler passed into the parser options to handle warnings\n * @return {Object}\n *        Object containing content steering data\n */\n\nconst generateContentSteeringInformation = (contentSteeringNodes, eventHandler) => {\n  // If there are more than one ContentSteering tags, throw an error\n  if (contentSteeringNodes.length > 1) {\n    eventHandler({\n      type: 'warn',\n      message: 'The MPD manifest should contain no more than one ContentSteering tag'\n    });\n  } // Return a null value if there are no ContentSteering tags\n\n\n  if (!contentSteeringNodes.length) {\n    return null;\n  }\n\n  const infoFromContentSteeringTag = merge({\n    serverURL: getContent(contentSteeringNodes[0])\n  }, parseAttributes(contentSteeringNodes[0])); // Converts `queryBeforeStart` to a boolean, as well as setting the default value\n  // to `false` if it doesn't exist\n\n  infoFromContentSteeringTag.queryBeforeStart = infoFromContentSteeringTag.queryBeforeStart === 'true';\n  return infoFromContentSteeringTag;\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\nconst getPeriodStart = ({\n  attributes,\n  priorPeriodAttributes,\n  mpdType\n}) => {\n  // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nconst inheritAttributes = (mpd, options = {}) => {\n  const {\n    manifestUri = '',\n    NOW = Date.now(),\n    clientOffset = 0,\n    // TODO: For now, we are expecting an eventHandler callback function\n    // to be passed into the mpd parser as an option.\n    // In the future, we should enable stream parsing by using the Stream class from vhs-utils.\n    // This will support new features including a standardized event handler.\n    // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.\n    // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9\n    eventHandler = function () {}\n  } = options;\n  const periodNodes = findChildren(mpd, 'Period');\n\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  const locations = findChildren(mpd, 'Location');\n  const mpdAttributes = parseAttributes(mpd);\n  const mpdBaseUrls = buildBaseUrls([{\n    baseUrl: manifestUri\n  }], findChildren(mpd, 'BaseURL'));\n  const contentSteeringNodes = findChildren(mpd, 'ContentSteering'); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n\n  const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach((node, index) => {\n    const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    const priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node,\n      attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    contentSteeringInfo: generateContentSteeringInformation(contentSteeringNodes, eventHandler),\n    // TODO: There are occurences where this `representationInfo` array contains undesired\n    // duplicates. This generally occurs when there are multiple BaseURL nodes that are\n    // direct children of the MPD node. When we attempt to resolve URLs from a combination of the\n    // parent BaseURL and a child BaseURL, and the value does not resolve,\n    // we end up returning the child BaseURL multiple times.\n    // We need to determine a way to remove these duplicates in a safe way.\n    // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls))),\n    eventStream: flatten(periods.map(toEventStream))\n  };\n};\n\nconst stringToMpdXml = manifestString => {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  const parser = new _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_4__.DOMParser();\n  let xml;\n  let mpd;\n\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throws on invalid xml\n  }\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nconst parseUTCTimingScheme = mpd => {\n  const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  const attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nconst VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nconst parse = (manifestString, options = {}) => {\n  const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    contentSteering: parsedManifestInfo.contentSteeringInfo,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest,\n    eventStream: parsedManifestInfo.eventStream\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nconst parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXBkLXBhcnNlci9kaXN0L21wZC1wYXJzZXIuZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDMkQ7QUFDeEI7QUFDb0M7QUFDYTtBQUN6Qzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFD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QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztB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O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHFEQUFTO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxXQUFXO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7O0FBRTZLIiwic291cmNlcyI6WyJFOlxcUHJvamVjdHNcXEthaWxhc2FQcm9qZWN0XFxvdHRcXEZyb250ZW5kXFxub2RlX21vZHVsZXNcXG1wZC1wYXJzZXJcXGRpc3RcXG1wZC1wYXJzZXIuZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEBuYW1lIG1wZC1wYXJzZXIgQHZlcnNpb24gMS4zLjEgQGxpY2Vuc2UgQXBhY2hlLTIuMCAqL1xuaW1wb3J0IHJlc29sdmVVcmwgZnJvbSAnQHZpZGVvanMvdmhzLXV0aWxzL2VzL3Jlc29sdmUtdXJsJztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQgeyBmb3JFYWNoTWVkaWFHcm91cCB9IGZyb20gJ0B2aWRlb2pzL3Zocy11dGlscy9lcy9tZWRpYS1ncm91cHMnO1xuaW1wb3J0IGRlY29kZUI2NFRvVWludDhBcnJheSBmcm9tICdAdmlkZW9qcy92aHMtdXRpbHMvZXMvZGVjb2RlLWI2NC10by11aW50OC1hcnJheSc7XG5pbXBvcnQgeyBET01QYXJzZXIgfSBmcm9tICdAeG1sZG9tL3htbGRvbSc7XG5cbnZhciB2ZXJzaW9uID0gXCIxLjMuMVwiO1xuXG5jb25zdCBpc09iamVjdCA9IG9iaiA9PiB7XG4gIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn07XG5cbmNvbnN0IG1lcmdlID0gKC4uLm9iamVjdHMpID0+IHtcbiAgcmV0dXJuIG9iamVjdHMucmVkdWNlKChyZXN1bHQsIHNvdXJjZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtrZXldKSAmJiBBcnJheS5pc0FycmF5KHNvdXJjZVtrZXldKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHJlc3VsdFtrZXldLmNvbmNhdChzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG59O1xuY29uc3QgdmFsdWVzID0gbyA9PiBPYmplY3Qua2V5cyhvKS5tYXAoayA9PiBvW2tdKTtcblxuY29uc3QgcmFuZ2UgPSAoc3RhcnQsIGVuZCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBmbGF0dGVuID0gbGlzdHMgPT4gbGlzdHMucmVkdWNlKCh4LCB5KSA9PiB4LmNvbmNhdCh5KSwgW10pO1xuY29uc3QgZnJvbSA9IGxpc3QgPT4ge1xuICBpZiAoIWxpc3QubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2gobGlzdFtpXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGZpbmRJbmRleGVzID0gKGwsIGtleSkgPT4gbC5yZWR1Y2UoKGEsIGUsIGkpID0+IHtcbiAgaWYgKGVba2V5XSkge1xuICAgIGEucHVzaChpKTtcbiAgfVxuXG4gIHJldHVybiBhO1xufSwgW10pO1xuLyoqXG4gKiBSZXR1cm5zIGEgdW5pb24gb2YgdGhlIGluY2x1ZGVkIGxpc3RzIHByb3ZpZGVkIGVhY2ggZWxlbWVudCBjYW4gYmUgaWRlbnRpZmllZCBieSBhIGtleS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IC0gbGlzdCBvZiBsaXN0cyB0byBnZXQgdGhlIHVuaW9uIG9mXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlGdW5jdGlvbiAtIHRoZSBmdW5jdGlvbiB0byB1c2UgYXMgYSBrZXkgZm9yIGVhY2ggZWxlbWVudFxuICpcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgdW5pb24gb2YgdGhlIGFycmF5c1xuICovXG5cbmNvbnN0IHVuaW9uID0gKGxpc3RzLCBrZXlGdW5jdGlvbikgPT4ge1xuICByZXR1cm4gdmFsdWVzKGxpc3RzLnJlZHVjZSgoYWNjLCBsaXN0KSA9PiB7XG4gICAgbGlzdC5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGFjY1trZXlGdW5jdGlvbihlbCldID0gZWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pKTtcbn07XG5cbnZhciBlcnJvcnMgPSB7XG4gIElOVkFMSURfTlVNQkVSX09GX1BFUklPRDogJ0lOVkFMSURfTlVNQkVSX09GX1BFUklPRCcsXG4gIElOVkFMSURfTlVNQkVSX09GX0NPTlRFTlRfU1RFRVJJTkc6ICdJTlZBTElEX05VTUJFUl9PRl9DT05URU5UX1NURUVSSU5HJyxcbiAgREFTSF9FTVBUWV9NQU5JRkVTVDogJ0RBU0hfRU1QVFlfTUFOSUZFU1QnLFxuICBEQVNIX0lOVkFMSURfWE1MOiAnREFTSF9JTlZBTElEX1hNTCcsXG4gIE5PX0JBU0VfVVJMOiAnTk9fQkFTRV9VUkwnLFxuICBNSVNTSU5HX1NFR01FTlRfSU5GT1JNQVRJT046ICdNSVNTSU5HX1NFR01FTlRfSU5GT1JNQVRJT04nLFxuICBTRUdNRU5UX1RJTUVfVU5TUEVDSUZJRUQ6ICdTRUdNRU5UX1RJTUVfVU5TUEVDSUZJRUQnLFxuICBVTlNVUFBPUlRFRF9VVENfVElNSU5HX1NDSEVNRTogJ1VOU1VQUE9SVEVEX1VUQ19USU1JTkdfU0NIRU1FJ1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaW5nbGVVcmlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmkgLSByZWxhdGl2ZSBsb2NhdGlvbiBvZiBzZWdtZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVzb2x2ZWRVcmkgLSByZXNvbHZlZCBsb2NhdGlvbiBvZiBzZWdtZW50XG4gKiBAcHJvcGVydHkge09iamVjdH0gYnl0ZXJhbmdlIC0gT2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gb24gaG93IHRvIG1ha2UgYnl0ZSByYW5nZVxuICogICByZXF1ZXN0cyBmb2xsb3dpbmcgYnl0ZS1yYW5nZS1zcGVjIHBlciBSRkMyNjE2LlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGJ5dGVyYW5nZS5sZW5ndGggLSBsZW5ndGggb2YgcmFuZ2UgcmVxdWVzdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGJ5dGVyYW5nZS5vZmZzZXQgLSBieXRlIG9mZnNldCBvZiByYW5nZSByZXF1ZXN0XG4gKlxuICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMxNC5odG1sI3NlYzE0LjM1LjFcbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVVJMVHlwZSBub2RlICg1LjMuOS4yLjMgVGFibGUgMTMpIHRvIGEgc2VnbWVudCBvYmplY3RcbiAqIHRoYXQgY29uZm9ybXMgdG8gaG93IG0zdTgtcGFyc2VyIGlzIHN0cnVjdHVyZWRcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL20zdTgtcGFyc2VyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVcmwgLSBiYXNlVXJsIHByb3ZpZGVkIGJ5IDxCYXNlVXJsPiBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIHNvdXJjZSB1cmwgZm9yIHNlZ21lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSByYW5nZSAtIG9wdGlvbmFsIHJhbmdlIHVzZWQgZm9yIHJhbmdlIGNhbGxzLFxuICogICBmb2xsb3dzICBSRkMgMjYxNiwgQ2xhdXNlIDE0LjM1LjFcbiAqIEByZXR1cm4ge1NpbmdsZVVyaX0gZnVsbCBzZWdtZW50IGluZm9ybWF0aW9uIHRyYW5zZm9ybWVkIGludG8gYSBmb3JtYXQgc2ltaWxhclxuICogICB0byBtM3U4LXBhcnNlclxuICovXG5cbmNvbnN0IHVybFR5cGVUb1NlZ21lbnQgPSAoe1xuICBiYXNlVXJsID0gJycsXG4gIHNvdXJjZSA9ICcnLFxuICByYW5nZSA9ICcnLFxuICBpbmRleFJhbmdlID0gJydcbn0pID0+IHtcbiAgY29uc3Qgc2VnbWVudCA9IHtcbiAgICB1cmk6IHNvdXJjZSxcbiAgICByZXNvbHZlZFVyaTogcmVzb2x2ZVVybChiYXNlVXJsIHx8ICcnLCBzb3VyY2UpXG4gIH07XG5cbiAgaWYgKHJhbmdlIHx8IGluZGV4UmFuZ2UpIHtcbiAgICBjb25zdCByYW5nZVN0ciA9IHJhbmdlID8gcmFuZ2UgOiBpbmRleFJhbmdlO1xuICAgIGNvbnN0IHJhbmdlcyA9IHJhbmdlU3RyLnNwbGl0KCctJyk7IC8vIGRlZmF1bHQgdG8gcGFyc2luZyB0aGlzIGFzIGEgQmlnSW50IGlmIHBvc3NpYmxlXG5cbiAgICBsZXQgc3RhcnRSYW5nZSA9IHdpbmRvdy5CaWdJbnQgPyB3aW5kb3cuQmlnSW50KHJhbmdlc1swXSkgOiBwYXJzZUludChyYW5nZXNbMF0sIDEwKTtcbiAgICBsZXQgZW5kUmFuZ2UgPSB3aW5kb3cuQmlnSW50ID8gd2luZG93LkJpZ0ludChyYW5nZXNbMV0pIDogcGFyc2VJbnQocmFuZ2VzWzFdLCAxMCk7IC8vIGNvbnZlcnQgYmFjayB0byBhIG51bWJlciBpZiBsZXNzIHRoYW4gTUFYX1NBRkVfSU5URUdFUlxuXG4gICAgaWYgKHN0YXJ0UmFuZ2UgPCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiB0eXBlb2Ygc3RhcnRSYW5nZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHN0YXJ0UmFuZ2UgPSBOdW1iZXIoc3RhcnRSYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKGVuZFJhbmdlIDwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiYgdHlwZW9mIGVuZFJhbmdlID09PSAnYmlnaW50Jykge1xuICAgICAgZW5kUmFuZ2UgPSBOdW1iZXIoZW5kUmFuZ2UpO1xuICAgIH1cblxuICAgIGxldCBsZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGVuZFJhbmdlID09PSAnYmlnaW50JyB8fCB0eXBlb2Ygc3RhcnRSYW5nZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIGxlbmd0aCA9IHdpbmRvdy5CaWdJbnQoZW5kUmFuZ2UpIC0gd2luZG93LkJpZ0ludChzdGFydFJhbmdlKSArIHdpbmRvdy5CaWdJbnQoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IGVuZFJhbmdlIC0gc3RhcnRSYW5nZSArIDE7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdiaWdpbnQnICYmIGxlbmd0aCA8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICB9IC8vIGJ5dGVyYW5nZSBzaG91bGQgYmUgaW5jbHVzaXZlIGFjY29yZGluZyB0b1xuICAgIC8vIFJGQyAyNjE2LCBDbGF1c2UgMTQuMzUuMVxuXG5cbiAgICBzZWdtZW50LmJ5dGVyYW5nZSA9IHtcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9mZnNldDogc3RhcnRSYW5nZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc2VnbWVudDtcbn07XG5jb25zdCBieXRlUmFuZ2VUb1N0cmluZyA9IGJ5dGVyYW5nZSA9PiB7XG4gIC8vIGBlbmRSYW5nZWAgaXMgb25lIGxlc3MgdGhhbiBgb2Zmc2V0ICsgbGVuZ3RoYCBiZWNhdXNlIHRoZSBIVFRQIHJhbmdlXG4gIC8vIGhlYWRlciB1c2VzIGluY2x1c2l2ZSByYW5nZXNcbiAgbGV0IGVuZFJhbmdlO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXJhbmdlLm9mZnNldCA9PT0gJ2JpZ2ludCcgfHwgdHlwZW9mIGJ5dGVyYW5nZS5sZW5ndGggPT09ICdiaWdpbnQnKSB7XG4gICAgZW5kUmFuZ2UgPSB3aW5kb3cuQmlnSW50KGJ5dGVyYW5nZS5vZmZzZXQpICsgd2luZG93LkJpZ0ludChieXRlcmFuZ2UubGVuZ3RoKSAtIHdpbmRvdy5CaWdJbnQoMSk7XG4gIH0gZWxzZSB7XG4gICAgZW5kUmFuZ2UgPSBieXRlcmFuZ2Uub2Zmc2V0ICsgYnl0ZXJhbmdlLmxlbmd0aCAtIDE7XG4gIH1cblxuICByZXR1cm4gYCR7Ynl0ZXJhbmdlLm9mZnNldH0tJHtlbmRSYW5nZX1gO1xufTtcblxuLyoqXG4gKiBwYXJzZSB0aGUgZW5kIG51bWJlciBhdHRyaWJ1ZSB0aGF0IGNhbiBiZSBhIHN0cmluZ1xuICogbnVtYmVyLCBvciB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfHVuZGVmaW5lZH0gZW5kTnVtYmVyXG4gKiAgICAgICAgVGhlIGVuZCBudW1iZXIgYXR0cmlidXRlLlxuICpcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfVxuICogICAgICAgICAgVGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSBlbmQgbnVtYmVyLlxuICovXG5cbmNvbnN0IHBhcnNlRW5kTnVtYmVyID0gZW5kTnVtYmVyID0+IHtcbiAgaWYgKGVuZE51bWJlciAmJiB0eXBlb2YgZW5kTnVtYmVyICE9PSAnbnVtYmVyJykge1xuICAgIGVuZE51bWJlciA9IHBhcnNlSW50KGVuZE51bWJlciwgMTApO1xuICB9XG5cbiAgaWYgKGlzTmFOKGVuZE51bWJlcikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbmROdW1iZXI7XG59O1xuLyoqXG4gKiBGdW5jdGlvbnMgZm9yIGNhbGN1bGF0aW5nIHRoZSByYW5nZSBvZiBhdmFpbGFibGUgc2VnbWVudHMgaW4gc3RhdGljIGFuZCBkeW5hbWljXG4gKiBtYW5pZmVzdHMuXG4gKi9cblxuXG5jb25zdCBzZWdtZW50UmFuZ2UgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbnRpcmUgcmFuZ2Ugb2YgYXZhaWxhYmxlIHNlZ21lbnRzIGZvciBhIHN0YXRpYyBNUERcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAgICogICAgICAgIEluaGVyaXRpZWQgTVBEIGF0dHJpYnV0ZXNcbiAgICogQHJldHVybiB7eyBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciB9fVxuICAgKiAgICAgICAgIFRoZSBzdGFydCBhbmQgZW5kIG51bWJlcnMgZm9yIGF2YWlsYWJsZSBzZWdtZW50c1xuICAgKi9cbiAgc3RhdGljKGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkdXJhdGlvbixcbiAgICAgIHRpbWVzY2FsZSA9IDEsXG4gICAgICBzb3VyY2VEdXJhdGlvbixcbiAgICAgIHBlcmlvZER1cmF0aW9uXG4gICAgfSA9IGF0dHJpYnV0ZXM7XG4gICAgY29uc3QgZW5kTnVtYmVyID0gcGFyc2VFbmROdW1iZXIoYXR0cmlidXRlcy5lbmROdW1iZXIpO1xuICAgIGNvbnN0IHNlZ21lbnREdXJhdGlvbiA9IGR1cmF0aW9uIC8gdGltZXNjYWxlO1xuXG4gICAgaWYgKHR5cGVvZiBlbmROdW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiBlbmROdW1iZXJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwZXJpb2REdXJhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IHBlcmlvZER1cmF0aW9uIC8gc2VnbWVudER1cmF0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogc291cmNlRHVyYXRpb24gLyBzZWdtZW50RHVyYXRpb25cbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxpdmUgd2luZG93IHJhbmdlIG9mIGF2YWlsYWJsZSBzZWdtZW50cyBmb3IgYSBkeW5hbWljIE1QRFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICAgKiAgICAgICAgSW5oZXJpdGllZCBNUEQgYXR0cmlidXRlc1xuICAgKiBAcmV0dXJuIHt7IHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyIH19XG4gICAqICAgICAgICAgVGhlIHN0YXJ0IGFuZCBlbmQgbnVtYmVycyBmb3IgYXZhaWxhYmxlIHNlZ21lbnRzXG4gICAqL1xuICBkeW5hbWljKGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBOT1csXG4gICAgICBjbGllbnRPZmZzZXQsXG4gICAgICBhdmFpbGFiaWxpdHlTdGFydFRpbWUsXG4gICAgICB0aW1lc2NhbGUgPSAxLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBwZXJpb2RTdGFydCA9IDAsXG4gICAgICBtaW5pbXVtVXBkYXRlUGVyaW9kID0gMCxcbiAgICAgIHRpbWVTaGlmdEJ1ZmZlckRlcHRoID0gSW5maW5pdHlcbiAgICB9ID0gYXR0cmlidXRlcztcbiAgICBjb25zdCBlbmROdW1iZXIgPSBwYXJzZUVuZE51bWJlcihhdHRyaWJ1dGVzLmVuZE51bWJlcik7IC8vIGNsaWVudE9mZnNldCBpcyBwYXNzZWQgaW4gYXQgdGhlIHRvcCBsZXZlbCBvZiBtcGQtcGFyc2VyIGFuZCBpcyBhbiBvZmZzZXQgY2FsY3VsYXRlZFxuICAgIC8vIGFmdGVyIHJldHJpZXZpbmcgVVRDIHNlcnZlciB0aW1lLlxuXG4gICAgY29uc3Qgbm93ID0gKE5PVyArIGNsaWVudE9mZnNldCkgLyAxMDAwOyAvLyBXQyBzdGFuZHMgZm9yIFdhbGwgQ2xvY2suXG4gICAgLy8gQ29udmVydCB0aGUgcGVyaW9kIHN0YXJ0IHRpbWUgdG8gRVBPQ0guXG5cbiAgICBjb25zdCBwZXJpb2RTdGFydFdDID0gYXZhaWxhYmlsaXR5U3RhcnRUaW1lICsgcGVyaW9kU3RhcnQ7IC8vIFBlcmlvZCBlbmQgaW4gRVBPQ0ggaXMgbWFuaWZlc3QncyByZXRyaWV2YWwgdGltZSArIHRpbWUgdW50aWwgbmV4dCB1cGRhdGUuXG5cbiAgICBjb25zdCBwZXJpb2RFbmRXQyA9IG5vdyArIG1pbmltdW1VcGRhdGVQZXJpb2Q7XG4gICAgY29uc3QgcGVyaW9kRHVyYXRpb24gPSBwZXJpb2RFbmRXQyAtIHBlcmlvZFN0YXJ0V0M7XG4gICAgY29uc3Qgc2VnbWVudENvdW50ID0gTWF0aC5jZWlsKHBlcmlvZER1cmF0aW9uICogdGltZXNjYWxlIC8gZHVyYXRpb24pO1xuICAgIGNvbnN0IGF2YWlsYWJsZVN0YXJ0ID0gTWF0aC5mbG9vcigobm93IC0gcGVyaW9kU3RhcnRXQyAtIHRpbWVTaGlmdEJ1ZmZlckRlcHRoKSAqIHRpbWVzY2FsZSAvIGR1cmF0aW9uKTtcbiAgICBjb25zdCBhdmFpbGFibGVFbmQgPSBNYXRoLmZsb29yKChub3cgLSBwZXJpb2RTdGFydFdDKSAqIHRpbWVzY2FsZSAvIGR1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IE1hdGgubWF4KDAsIGF2YWlsYWJsZVN0YXJ0KSxcbiAgICAgIGVuZDogdHlwZW9mIGVuZE51bWJlciA9PT0gJ251bWJlcicgPyBlbmROdW1iZXIgOiBNYXRoLm1pbihzZWdtZW50Q291bnQsIGF2YWlsYWJsZUVuZClcbiAgICB9O1xuICB9XG5cbn07XG4vKipcbiAqIE1hcHMgYSByYW5nZSBvZiBudW1iZXJzIHRvIG9iamVjdHMgd2l0aCBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gYnVpbGQgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIHNlZ21lbnQgbGlzdFxuICpcbiAqIEBuYW1lIHRvU2VnbWVudHNDYWxsYmFja1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gKiAgICAgICAgTnVtYmVyIG9mIHRoZSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqICAgICAgICBJbmRleCBvZiB0aGUgbnVtYmVyIGluIHRoZSByYW5nZSBsaXN0XG4gKiBAcmV0dXJuIHt7IG51bWJlcjogTnVtYmVyLCBkdXJhdGlvbjogTnVtYmVyLCB0aW1lbGluZTogTnVtYmVyLCB0aW1lOiBOdW1iZXIgfX1cbiAqICAgICAgICAgT2JqZWN0IHdpdGggc2VnbWVudCB0aW1pbmcgYW5kIGR1cmF0aW9uIGluZm9cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBjYWxsYmFjayBmb3IgQXJyYXkucHJvdG90eXBlLm1hcCBmb3IgbWFwcGluZyBhIHJhbmdlIG9mIG51bWJlcnMgdG9cbiAqIGluZm9ybWF0aW9uIG5lZWRlZCB0byBidWlsZCB0aGUgc2VnbWVudCBsaXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgSW5oZXJpdGVkIE1QRCBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHt0b1NlZ21lbnRzQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIG1hcCBmdW5jdGlvblxuICovXG5cbmNvbnN0IHRvU2VnbWVudHMgPSBhdHRyaWJ1dGVzID0+IG51bWJlciA9PiB7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbixcbiAgICB0aW1lc2NhbGUgPSAxLFxuICAgIHBlcmlvZFN0YXJ0LFxuICAgIHN0YXJ0TnVtYmVyID0gMVxuICB9ID0gYXR0cmlidXRlcztcbiAgcmV0dXJuIHtcbiAgICBudW1iZXI6IHN0YXJ0TnVtYmVyICsgbnVtYmVyLFxuICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICB0aW1lbGluZTogcGVyaW9kU3RhcnQsXG4gICAgdGltZTogbnVtYmVyICogZHVyYXRpb25cbiAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBzZWdtZW50IHRpbWluZyBhbmQgZHVyYXRpb24gaW5mbyB1c2VkIGZvclxuICogYnVpbGRpbmcgdGhlIGxpc3Qgb2Ygc2VnbWVudHMuIFRoaXMgdXNlcyB0aGUgQGR1cmF0aW9uIGF0dHJpYnV0ZSBzcGVjaWZpZWRcbiAqIGluIHRoZSBNUEQgbWFuaWZlc3QgdG8gZGVyaXZlIHRoZSByYW5nZSBvZiBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIEluaGVyaXRlZCBNUEQgYXR0cmlidXRlc1xuICogQHJldHVybiB7e251bWJlcjogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiBudW1iZXIsIHRpbWVsaW5lOiBudW1iZXJ9W119XG4gKiAgICAgICAgIExpc3Qgb2YgT2JqZWN0cyB3aXRoIHNlZ21lbnQgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvXG4gKi9cblxuY29uc3QgcGFyc2VCeUR1cmF0aW9uID0gYXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIGR1cmF0aW9uLFxuICAgIHRpbWVzY2FsZSA9IDEsXG4gICAgcGVyaW9kRHVyYXRpb24sXG4gICAgc291cmNlRHVyYXRpb25cbiAgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IHtcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgfSA9IHNlZ21lbnRSYW5nZVt0eXBlXShhdHRyaWJ1dGVzKTtcbiAgY29uc3Qgc2VnbWVudHMgPSByYW5nZShzdGFydCwgZW5kKS5tYXAodG9TZWdtZW50cyhhdHRyaWJ1dGVzKSk7XG5cbiAgaWYgKHR5cGUgPT09ICdzdGF0aWMnKSB7XG4gICAgY29uc3QgaW5kZXggPSBzZWdtZW50cy5sZW5ndGggLSAxOyAvLyBzZWN0aW9uIGlzIGVpdGhlciBhIHBlcmlvZCBvciB0aGUgZnVsbCBzb3VyY2VcblxuICAgIGNvbnN0IHNlY3Rpb25EdXJhdGlvbiA9IHR5cGVvZiBwZXJpb2REdXJhdGlvbiA9PT0gJ251bWJlcicgPyBwZXJpb2REdXJhdGlvbiA6IHNvdXJjZUR1cmF0aW9uOyAvLyBmaW5hbCBzZWdtZW50IG1heSBiZSBsZXNzIHRoYW4gZnVsbCBzZWdtZW50IGR1cmF0aW9uXG5cbiAgICBzZWdtZW50c1tpbmRleF0uZHVyYXRpb24gPSBzZWN0aW9uRHVyYXRpb24gLSBkdXJhdGlvbiAvIHRpbWVzY2FsZSAqIGluZGV4O1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIFNlZ21lbnRCYXNlIGludG8gYSBzZXQgb2Ygc2VnbWVudHMuXG4gKiAoREFTSCBTUEVDIFNlY3Rpb24gNS4zLjkuMy4yKSBjb250YWlucyBhIHNldCBvZiA8U2VnbWVudFVSTD4gbm9kZXMuICBFYWNoXG4gKiBub2RlIHNob3VsZCBiZSB0cmFuc2xhdGVkIGludG8gc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgbmFtZXMgYXMga2V5c1xuICogQHJldHVybiB7T2JqZWN0LjxBcnJheT59IGxpc3Qgb2Ygc2VnbWVudHNcbiAqL1xuXG5jb25zdCBzZWdtZW50c0Zyb21CYXNlID0gYXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHtcbiAgICBiYXNlVXJsLFxuICAgIGluaXRpYWxpemF0aW9uID0ge30sXG4gICAgc291cmNlRHVyYXRpb24sXG4gICAgaW5kZXhSYW5nZSA9ICcnLFxuICAgIHBlcmlvZFN0YXJ0LFxuICAgIHByZXNlbnRhdGlvblRpbWUsXG4gICAgbnVtYmVyID0gMCxcbiAgICBkdXJhdGlvblxuICB9ID0gYXR0cmlidXRlczsgLy8gYmFzZSB1cmwgaXMgcmVxdWlyZWQgZm9yIFNlZ21lbnRCYXNlIHRvIHdvcmssIHBlciBzcGVjIChTZWN0aW9uIDUuMy45LjIuMSlcblxuICBpZiAoIWJhc2VVcmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLk5PX0JBU0VfVVJMKTtcbiAgfVxuXG4gIGNvbnN0IGluaXRTZWdtZW50ID0gdXJsVHlwZVRvU2VnbWVudCh7XG4gICAgYmFzZVVybCxcbiAgICBzb3VyY2U6IGluaXRpYWxpemF0aW9uLnNvdXJjZVVSTCxcbiAgICByYW5nZTogaW5pdGlhbGl6YXRpb24ucmFuZ2VcbiAgfSk7XG4gIGNvbnN0IHNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHtcbiAgICBiYXNlVXJsLFxuICAgIHNvdXJjZTogYmFzZVVybCxcbiAgICBpbmRleFJhbmdlXG4gIH0pO1xuICBzZWdtZW50Lm1hcCA9IGluaXRTZWdtZW50OyAvLyBJZiB0aGVyZSBpcyBhIGR1cmF0aW9uLCB1c2UgaXQsIG90aGVyd2lzZSB1c2UgdGhlIGdpdmVuIGR1cmF0aW9uIG9mIHRoZSBzb3VyY2VcbiAgLy8gKHNpbmNlIFNlZ21lbnRCYXNlIGlzIG9ubHkgZm9yIG9uZSB0b3RhbCBzZWdtZW50KVxuXG4gIGlmIChkdXJhdGlvbikge1xuICAgIGNvbnN0IHNlZ21lbnRUaW1lSW5mbyA9IHBhcnNlQnlEdXJhdGlvbihhdHRyaWJ1dGVzKTtcblxuICAgIGlmIChzZWdtZW50VGltZUluZm8ubGVuZ3RoKSB7XG4gICAgICBzZWdtZW50LmR1cmF0aW9uID0gc2VnbWVudFRpbWVJbmZvWzBdLmR1cmF0aW9uO1xuICAgICAgc2VnbWVudC50aW1lbGluZSA9IHNlZ21lbnRUaW1lSW5mb1swXS50aW1lbGluZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc291cmNlRHVyYXRpb24pIHtcbiAgICBzZWdtZW50LmR1cmF0aW9uID0gc291cmNlRHVyYXRpb247XG4gICAgc2VnbWVudC50aW1lbGluZSA9IHBlcmlvZFN0YXJ0O1xuICB9IC8vIElmIHByZXNlbnRhdGlvbiB0aW1lIGlzIHByb3ZpZGVkLCB0aGVzZSBzZWdtZW50cyBhcmUgYmVpbmcgZ2VuZXJhdGVkIGJ5IFNJRFhcbiAgLy8gcmVmZXJlbmNlcywgYW5kIHNob3VsZCB1c2UgdGhlIHRpbWUgcHJvdmlkZWQuIEZvciB0aGUgZ2VuZXJhbCBjYXNlIG9mIFNlZ21lbnRCYXNlLFxuICAvLyB0aGVyZSBzaG91bGQgb25seSBiZSBvbmUgc2VnbWVudCBpbiB0aGUgcGVyaW9kLCBzbyBpdHMgcHJlc2VudGF0aW9uIHRpbWUgaXMgdGhlIHNhbWVcbiAgLy8gYXMgaXRzIHBlcmlvZCBzdGFydC5cblxuXG4gIHNlZ21lbnQucHJlc2VudGF0aW9uVGltZSA9IHByZXNlbnRhdGlvblRpbWUgfHwgcGVyaW9kU3RhcnQ7XG4gIHNlZ21lbnQubnVtYmVyID0gbnVtYmVyO1xuICByZXR1cm4gW3NlZ21lbnRdO1xufTtcbi8qKlxuICogR2l2ZW4gYSBwbGF5bGlzdCwgYSBzaWR4IGJveCwgYW5kIGEgYmFzZVVybCwgdXBkYXRlIHRoZSBzZWdtZW50IGxpc3Qgb2YgdGhlIHBsYXlsaXN0XG4gKiBhY2NvcmRpbmcgdG8gdGhlIHNpZHggaW5mb3JtYXRpb24gZ2l2ZW4uXG4gKlxuICogcGxheWxpc3Quc2lkeCBoYXMgbWV0YWRhZGF0YSBhYm91dCB0aGUgc2lkeCB3aGVyZS1hcyB0aGUgc2lkeCBwYXJhbVxuICogaXMgdGhlIHBhcnNlZCBzaWR4IGJveCBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0IHRoZSBwbGF5bGlzdCB0byB1cGRhdGUgdGhlIHNpZHggaW5mb3JtYXRpb24gZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gc2lkeCB0aGUgcGFyc2VkIHNpZHggYm94XG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwbGF5bGlzdCBvYmplY3Qgd2l0aCB0aGUgdXBkYXRlZCBzaWR4IGluZm9ybWF0aW9uXG4gKi9cblxuY29uc3QgYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCQxID0gKHBsYXlsaXN0LCBzaWR4LCBiYXNlVXJsKSA9PiB7XG4gIC8vIFJldGFpbiBpbml0IHNlZ21lbnQgaW5mb3JtYXRpb25cbiAgY29uc3QgaW5pdFNlZ21lbnQgPSBwbGF5bGlzdC5zaWR4Lm1hcCA/IHBsYXlsaXN0LnNpZHgubWFwIDogbnVsbDsgLy8gUmV0YWluIHNvdXJjZSBkdXJhdGlvbiBmcm9tIGluaXRpYWwgbWFpbiBtYW5pZmVzdCBwYXJzaW5nXG5cbiAgY29uc3Qgc291cmNlRHVyYXRpb24gPSBwbGF5bGlzdC5zaWR4LmR1cmF0aW9uOyAvLyBSZXRhaW4gc291cmNlIHRpbWVsaW5lXG5cbiAgY29uc3QgdGltZWxpbmUgPSBwbGF5bGlzdC50aW1lbGluZSB8fCAwO1xuICBjb25zdCBzaWR4Qnl0ZVJhbmdlID0gcGxheWxpc3Quc2lkeC5ieXRlcmFuZ2U7XG4gIGNvbnN0IHNpZHhFbmQgPSBzaWR4Qnl0ZVJhbmdlLm9mZnNldCArIHNpZHhCeXRlUmFuZ2UubGVuZ3RoOyAvLyBSZXRhaW4gdGltZXNjYWxlIG9mIHRoZSBwYXJzZWQgc2lkeFxuXG4gIGNvbnN0IHRpbWVzY2FsZSA9IHNpZHgudGltZXNjYWxlOyAvLyByZWZlcmVuY2VUeXBlIDEgcmVmZXJzIHRvIG90aGVyIHNpZHggYm94ZXNcblxuICBjb25zdCBtZWRpYVJlZmVyZW5jZXMgPSBzaWR4LnJlZmVyZW5jZXMuZmlsdGVyKHIgPT4gci5yZWZlcmVuY2VUeXBlICE9PSAxKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgY29uc3QgdHlwZSA9IHBsYXlsaXN0LmVuZExpc3QgPyAnc3RhdGljJyA6ICdkeW5hbWljJztcbiAgY29uc3QgcGVyaW9kU3RhcnQgPSBwbGF5bGlzdC5zaWR4LnRpbWVsaW5lO1xuICBsZXQgcHJlc2VudGF0aW9uVGltZSA9IHBlcmlvZFN0YXJ0O1xuICBsZXQgbnVtYmVyID0gcGxheWxpc3QubWVkaWFTZXF1ZW5jZSB8fCAwOyAvLyBmaXJzdE9mZnNldCBpcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgc2lkeCBib3hcblxuICBsZXQgc3RhcnRJbmRleDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgaWYgKHR5cGVvZiBzaWR4LmZpcnN0T2Zmc2V0ID09PSAnYmlnaW50Jykge1xuICAgIHN0YXJ0SW5kZXggPSB3aW5kb3cuQmlnSW50KHNpZHhFbmQpICsgc2lkeC5maXJzdE9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydEluZGV4ID0gc2lkeEVuZCArIHNpZHguZmlyc3RPZmZzZXQ7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZGlhUmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlZmVyZW5jZSA9IHNpZHgucmVmZXJlbmNlc1tpXTsgLy8gc2l6ZSBvZiB0aGUgcmVmZXJlbmNlZCAoc3ViKXNlZ21lbnRcblxuICAgIGNvbnN0IHNpemUgPSByZWZlcmVuY2UucmVmZXJlbmNlZFNpemU7IC8vIGR1cmF0aW9uIG9mIHRoZSByZWZlcmVuY2VkIChzdWIpc2VnbWVudCwgaW4gIHRoZSAgdGltZXNjYWxlXG4gICAgLy8gdGhpcyB3aWxsIGJlIGNvbnZlcnRlZCB0byBzZWNvbmRzIHdoZW4gZ2VuZXJhdGluZyBzZWdtZW50c1xuXG4gICAgY29uc3QgZHVyYXRpb24gPSByZWZlcmVuY2Uuc3Vic2VnbWVudER1cmF0aW9uOyAvLyBzaG91bGQgYmUgYW4gaW5jbHVzaXZlIHJhbmdlXG5cbiAgICBsZXQgZW5kSW5kZXg7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAnYmlnaW50Jykge1xuICAgICAgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgd2luZG93LkJpZ0ludChzaXplKSAtIHdpbmRvdy5CaWdJbnQoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHNpemUgLSAxO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4UmFuZ2UgPSBgJHtzdGFydEluZGV4fS0ke2VuZEluZGV4fWA7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIGJhc2VVcmwsXG4gICAgICB0aW1lc2NhbGUsXG4gICAgICB0aW1lbGluZSxcbiAgICAgIHBlcmlvZFN0YXJ0LFxuICAgICAgcHJlc2VudGF0aW9uVGltZSxcbiAgICAgIG51bWJlcixcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgc291cmNlRHVyYXRpb24sXG4gICAgICBpbmRleFJhbmdlLFxuICAgICAgdHlwZVxuICAgIH07XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzRnJvbUJhc2UoYXR0cmlidXRlcylbMF07XG5cbiAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgIHNlZ21lbnQubWFwID0gaW5pdFNlZ21lbnQ7XG4gICAgfVxuXG4gICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcblxuICAgIGlmICh0eXBlb2Ygc3RhcnRJbmRleCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHN0YXJ0SW5kZXggKz0gd2luZG93LkJpZ0ludChzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRJbmRleCArPSBzaXplO1xuICAgIH1cblxuICAgIHByZXNlbnRhdGlvblRpbWUgKz0gZHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgbnVtYmVyKys7XG4gIH1cblxuICBwbGF5bGlzdC5zZWdtZW50cyA9IHNlZ21lbnRzO1xuICByZXR1cm4gcGxheWxpc3Q7XG59O1xuXG5jb25zdCBTVVBQT1JURURfTUVESUFfVFlQRVMgPSBbJ0FVRElPJywgJ1NVQlRJVExFUyddOyAvLyBhbGxvdyBvbmUgNjBmcHMgZnJhbWUgYXMgbGVuaWVuY3kgKGFyYml0cmFyaWx5IGNob3NlbilcblxuY29uc3QgVElNRV9GVURHRSA9IDEgLyA2MDtcbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIHRpbWVsaW5lU3RhcnRzLCBjb21iaW5lcywgZGVkdXBlcywgYW5kIHNvcnRzIHRoZW0uXG4gKlxuICogQHBhcmFtIHtUaW1lbGluZVN0YXJ0W119IHRpbWVsaW5lU3RhcnRzIC0gbGlzdCBvZiB0aW1lbGluZSBzdGFydHNcbiAqXG4gKiBAcmV0dXJuIHtUaW1lbGluZVN0YXJ0W119IHRoZSBjb21iaW5lZCBhbmQgZGVkdXBlZCB0aW1lbGluZSBzdGFydHNcbiAqL1xuXG5jb25zdCBnZXRVbmlxdWVUaW1lbGluZVN0YXJ0cyA9IHRpbWVsaW5lU3RhcnRzID0+IHtcbiAgcmV0dXJuIHVuaW9uKHRpbWVsaW5lU3RhcnRzLCAoe1xuICAgIHRpbWVsaW5lXG4gIH0pID0+IHRpbWVsaW5lKS5zb3J0KChhLCBiKSA9PiBhLnRpbWVsaW5lID4gYi50aW1lbGluZSA/IDEgOiAtMSk7XG59O1xuLyoqXG4gKiBGaW5kcyB0aGUgcGxheWxpc3Qgd2l0aCB0aGUgbWF0Y2hpbmcgTkFNRSBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGxheWxpc3RzIC0gcGxheWxpc3RzIHRvIHNlYXJjaCB0aHJvdWdoXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBOQU1FIGF0dHJpYnV0ZSB0byBzZWFyY2ggZm9yXG4gKlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9IHRoZSBtYXRjaGluZyBwbGF5bGlzdCBvYmplY3QsIG9yIG51bGxcbiAqL1xuXG5jb25zdCBmaW5kUGxheWxpc3RXaXRoTmFtZSA9IChwbGF5bGlzdHMsIG5hbWUpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGF5bGlzdHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGxheWxpc3RzW2ldLmF0dHJpYnV0ZXMuTkFNRSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIHBsYXlsaXN0c1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIEdldHMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgbWVkaWEgZ3JvdXAgcGxheWxpc3RzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5pZmVzdCAtIHRoZSBtYWluIG1hbmlmZXN0IG9iamVjdFxuICpcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgbWVkaWEgZ3JvdXAgcGxheWxpc3RzXG4gKi9cblxuY29uc3QgZ2V0TWVkaWFHcm91cFBsYXlsaXN0cyA9IG1hbmlmZXN0ID0+IHtcbiAgbGV0IG1lZGlhR3JvdXBQbGF5bGlzdHMgPSBbXTtcbiAgZm9yRWFjaE1lZGlhR3JvdXAobWFuaWZlc3QsIFNVUFBPUlRFRF9NRURJQV9UWVBFUywgKHByb3BlcnRpZXMsIHR5cGUsIGdyb3VwLCBsYWJlbCkgPT4ge1xuICAgIG1lZGlhR3JvdXBQbGF5bGlzdHMgPSBtZWRpYUdyb3VwUGxheWxpc3RzLmNvbmNhdChwcm9wZXJ0aWVzLnBsYXlsaXN0cyB8fCBbXSk7XG4gIH0pO1xuICByZXR1cm4gbWVkaWFHcm91cFBsYXlsaXN0cztcbn07XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBsYXlsaXN0J3MgbWVkaWEgc2VxdWVuY2UgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcucGxheWxpc3QgLSB0aGUgcGxheWxpc3QgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLm1lZGlhU2VxdWVuY2UgLSB0aGUgbWVkaWFTZXF1ZW5jZSBudW1iZXIgdG8gc3RhcnQgd2l0aFxuICovXG5cbmNvbnN0IHVwZGF0ZU1lZGlhU2VxdWVuY2VGb3JQbGF5bGlzdCA9ICh7XG4gIHBsYXlsaXN0LFxuICBtZWRpYVNlcXVlbmNlXG59KSA9PiB7XG4gIHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgPSBtZWRpYVNlcXVlbmNlO1xuICBwbGF5bGlzdC5zZWdtZW50cy5mb3JFYWNoKChzZWdtZW50LCBpbmRleCkgPT4ge1xuICAgIHNlZ21lbnQubnVtYmVyID0gcGxheWxpc3QubWVkaWFTZXF1ZW5jZSArIGluZGV4O1xuICB9KTtcbn07XG4vKipcbiAqIFVwZGF0ZXMgdGhlIG1lZGlhIGFuZCBkaXNjb250aW51aXR5IHNlcXVlbmNlIG51bWJlcnMgb2YgbmV3UGxheWxpc3RzIGdpdmVuIG9sZFBsYXlsaXN0c1xuICogYW5kIGEgY29tcGxldGUgbGlzdCBvZiB0aW1lbGluZSBzdGFydHMuXG4gKlxuICogSWYgbm8gbWF0Y2hpbmcgcGxheWxpc3QgaXMgZm91bmQsIG9ubHkgdGhlIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBwbGF5bGlzdFxuICogd2lsbCBiZSB1cGRhdGVkLlxuICpcbiAqIFNpbmNlIGVhcmx5IGF2YWlsYWJsZSB0aW1lbGluZXMgYXJlIG5vdCBzdXBwb3J0ZWQsIGF0IGxlYXN0IG9uZSBzZWdtZW50IG11c3QgYmUgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFBsYXlsaXN0cyAtIHRoZSBvbGQgcGxheWxpc3RzIHRvIHVzZSBhcyBhIHJlZmVyZW5jZVxuICogQHBhcmFtIHtPYmplY3RbXX0gbmV3UGxheWxpc3RzIC0gdGhlIG5ldyBwbGF5bGlzdHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdGltZWxpbmVTdGFydHMgLSBhbGwgdGltZWxpbmVTdGFydHMgc2VlbiBpbiB0aGUgc3RyZWFtIHRvIHRoaXMgcG9pbnRcbiAqL1xuXG5jb25zdCB1cGRhdGVTZXF1ZW5jZU51bWJlcnMgPSAoe1xuICBvbGRQbGF5bGlzdHMsXG4gIG5ld1BsYXlsaXN0cyxcbiAgdGltZWxpbmVTdGFydHNcbn0pID0+IHtcbiAgbmV3UGxheWxpc3RzLmZvckVhY2gocGxheWxpc3QgPT4ge1xuICAgIHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTZXF1ZW5jZSA9IHRpbWVsaW5lU3RhcnRzLmZpbmRJbmRleChmdW5jdGlvbiAoe1xuICAgICAgdGltZWxpbmVcbiAgICB9KSB7XG4gICAgICByZXR1cm4gdGltZWxpbmUgPT09IHBsYXlsaXN0LnRpbWVsaW5lO1xuICAgIH0pOyAvLyBQbGF5bGlzdHMgTkFNRXMgY29tZSBmcm9tIERBU0ggUmVwcmVzZW50YXRpb24gSURzLCB3aGljaCBhcmUgbWFuZGF0b3J5XG4gICAgLy8gKHNlZSBJU09fMjMwMDktMS0yMDEyIDUuMy41LjIpLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIHNhbWUgUmVwcmVzZW50YXRpb24gZXhpc3RlZCBpbiBhIHByaW9yIFBlcmlvZCwgaXQgd2lsbCByZXRhaW4gdGhlIHNhbWUgTkFNRS5cblxuICAgIGNvbnN0IG9sZFBsYXlsaXN0ID0gZmluZFBsYXlsaXN0V2l0aE5hbWUob2xkUGxheWxpc3RzLCBwbGF5bGlzdC5hdHRyaWJ1dGVzLk5BTUUpO1xuXG4gICAgaWYgKCFvbGRQbGF5bGlzdCkge1xuICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIG5ldyBwbGF5bGlzdCwgdGhlIG1lZGlhIHNlcXVlbmNlIHZhbHVlcyBjYW4gc3RhcnQgZnJvbSAwIHdpdGhvdXRcbiAgICAgIC8vIGNvbnNlcXVlbmNlLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVE9ETyBiZXR0ZXIgc3VwcG9ydCBmb3IgbGl2ZSBTSURYXG4gICAgLy9cbiAgICAvLyBBcyBvZiB0aGlzIHdyaXRpbmcsIG1wZC1wYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBlcmlvZCBTSURYIChpbiBsaXZlIG9yIFZPRCkuXG4gICAgLy8gVGhpcyBpcyBldmlkZW50IGJ5IGEgcGxheWxpc3Qgb25seSBoYXZpbmcgYSBzaW5nbGUgU0lEWCByZWZlcmVuY2UuIEluIGEgbXVsdGlwZXJpb2RcbiAgICAvLyBwbGF5bGlzdCB0aGVyZSB3b3VsZCBuZWVkIHRvIGJlIG11bHRpcGxlIFNJRFggcmVmZXJlbmNlcy4gSW4gYWRkaXRpb24sIGxpdmUgU0lEWCBpc1xuICAgIC8vIG5vdCBzdXBwb3J0ZWQgd2hlbiB0aGUgU0lEWCBwcm9wZXJ0aWVzIGNoYW5nZSBvbiByZWZyZXNoZXMuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgZnV0dXJlLCBpZiBzdXBwb3J0IG5lZWRzIHRvIGJlIGFkZGVkLCB0aGUgbWVyZ2luZyBsb2dpYyBoZXJlIGNhbiBiZSBjYWxsZWRcbiAgICAvLyBhZnRlciBTSURYIHJlZmVyZW5jZXMgYXJlIHJlc29sdmVkLiBGb3Igbm93LCBleGl0IGVhcmx5IHRvIHByZXZlbnQgZXhjZXB0aW9ucyBiZWluZ1xuICAgIC8vIHRocm93biBkdWUgdG8gdW5kZWZpbmVkIHJlZmVyZW5jZXMuXG5cblxuICAgIGlmIChwbGF5bGlzdC5zaWR4KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTaW5jZSB3ZSBkb24ndCB5ZXQgc3VwcG9ydCBlYXJseSBhdmFpbGFibGUgdGltZWxpbmVzLCB3ZSBkb24ndCBuZWVkIHRvIHN1cHBvcnRcbiAgICAvLyBwbGF5bGlzdHMgd2l0aCBubyBzZWdtZW50cy5cblxuXG4gICAgY29uc3QgZmlyc3ROZXdTZWdtZW50ID0gcGxheWxpc3Quc2VnbWVudHNbMF07XG4gICAgY29uc3Qgb2xkTWF0Y2hpbmdTZWdtZW50SW5kZXggPSBvbGRQbGF5bGlzdC5zZWdtZW50cy5maW5kSW5kZXgoZnVuY3Rpb24gKG9sZFNlZ21lbnQpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhvbGRTZWdtZW50LnByZXNlbnRhdGlvblRpbWUgLSBmaXJzdE5ld1NlZ21lbnQucHJlc2VudGF0aW9uVGltZSkgPCBUSU1FX0ZVREdFO1xuICAgIH0pOyAvLyBObyBtYXRjaGluZyBzZWdtZW50IGZyb20gdGhlIG9sZCBwbGF5bGlzdCBtZWFucyB0aGUgZW50aXJlIHBsYXlsaXN0IHdhcyByZWZyZXNoZWQuXG4gICAgLy8gSW4gdGhpcyBjYXNlIHRoZSBtZWRpYSBzZXF1ZW5jZSBzaG91bGQgYWNjb3VudCBmb3IgdGhpcyB1cGRhdGUsIGFuZCB0aGUgbmV3IHNlZ21lbnRzXG4gICAgLy8gc2hvdWxkIGJlIG1hcmtlZCBhcyBkaXNjb250aW51b3VzIGZyb20gdGhlIHByaW9yIGNvbnRlbnQsIHNpbmNlIHRoZSBsYXN0IHByaW9yXG4gICAgLy8gdGltZWxpbmUgd2FzIHJlbW92ZWQuXG5cbiAgICBpZiAob2xkTWF0Y2hpbmdTZWdtZW50SW5kZXggPT09IC0xKSB7XG4gICAgICB1cGRhdGVNZWRpYVNlcXVlbmNlRm9yUGxheWxpc3Qoe1xuICAgICAgICBwbGF5bGlzdCxcbiAgICAgICAgbWVkaWFTZXF1ZW5jZTogb2xkUGxheWxpc3QubWVkaWFTZXF1ZW5jZSArIG9sZFBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBwbGF5bGlzdC5zZWdtZW50c1swXS5kaXNjb250aW51aXR5ID0gdHJ1ZTtcbiAgICAgIHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTdGFydHMudW5zaGlmdCgwKTsgLy8gTm8gbWF0Y2hpbmcgc2VnbWVudCBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuIHRoZXJlJ3MgbWlzc2luZyBjb250ZW50LlxuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBuZXcgcGxheWxpc3QncyB0aW1lbGluZSBpcyB0aGUgc2FtZSBhcyB0aGUgbGFzdCBzZWVuIHNlZ21lbnQncyB0aW1lbGluZSxcbiAgICAgIC8vIHRoZW4gYSBkaXNjb250aW51aXR5IGNhbiBiZSBhZGRlZCB0byBpZGVudGlmeSB0aGF0IHRoZXJlJ3MgcG90ZW50aWFsbHkgbWlzc2luZ1xuICAgICAgLy8gY29udGVudC4gSWYgdGhlcmUncyBubyBtaXNzaW5nIGNvbnRlbnQsIHRoZSBkaXNjb250aW51aXR5IHNob3VsZCBzdGlsbCBiZSByYXRoZXJcbiAgICAgIC8vIGhhcm1sZXNzLiBJdCdzIHBvc3NpYmxlIHRoYXQgaWYgc2VnbWVudCBkdXJhdGlvbnMgYXJlIGFjY3VyYXRlIGVub3VnaCwgdGhhdCB0aGVcbiAgICAgIC8vIGV4aXN0ZW5jZSBvZiBhIGdhcCBjYW4gYmUgZGV0ZXJtaW5lZCB1c2luZyB0aGUgcHJlc2VudGF0aW9uIHRpbWVzIGFuZCBkdXJhdGlvbnMsXG4gICAgICAvLyBidXQgaWYgdGhlIHNlZ21lbnQgdGltaW5nIGluZm8gaXMgb2ZmLCBpdCBtYXkgaW50cm9kdWNlIG1vcmUgcHJvYmxlbXMgdGhhbiBzaW1wbHlcbiAgICAgIC8vIGFkZGluZyB0aGUgZGlzY29udGludWl0eS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgbmV3IHBsYXlsaXN0J3MgdGltZWxpbmUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGxhc3Qgc2VlbiBzZWdtZW50J3MgdGltZWxpbmUsXG4gICAgICAvLyB0aGVuIGEgZGlzY29udGludWl0eSBjYW4gYmUgYWRkZWQgdG8gaWRlbnRpZnkgdGhhdCB0aGlzIGlzIHRoZSBmaXJzdCBzZWVuIHNlZ21lbnRcbiAgICAgIC8vIG9mIGEgbmV3IHRpbWVsaW5lLiBIb3dldmVyLCB0aGUgbG9naWMgYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb24gdGhhdFxuICAgICAgLy8gZGV0ZXJtaW5lZCB0aGUgZGlzY29uaW51aXR5IHNlcXVlbmNlIGJ5IHRpbWVsaW5lIGluZGV4IGlzIG5vdyBvZmYgYnkgb25lICh0aGVcbiAgICAgIC8vIGRpc2NvbnRpbnVpdHkgb2YgdGhlIG5ld2VzdCB0aW1lbGluZSBoYXNuJ3QgeWV0IGZhbGxlbiBvZmYgdGhlIG1hbmlmZXN0Li4uc2luY2VcbiAgICAgIC8vIHdlIGFkZGVkIGl0KSwgc28gdGhlIGRpc2NvbmludWl0eSBzZXF1ZW5jZSBtdXN0IGJlIGRlY3JlbWVudGVkLlxuICAgICAgLy9cbiAgICAgIC8vIEEgcGVyaW9kIG1heSBhbHNvIGhhdmUgYSBkdXJhdGlvbiBvZiB6ZXJvLCBzbyB0aGUgY2FzZSBvZiBubyBzZWdtZW50cyBpcyBoYW5kbGVkXG4gICAgICAvLyBoZXJlIGV2ZW4gdGhvdWdoIHdlIGRvbid0IHlldCBzdXBwb3J0IGVhcmx5IGF2YWlsYWJsZSBwZXJpb2RzLlxuXG4gICAgICBpZiAoIW9sZFBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCAmJiBwbGF5bGlzdC50aW1lbGluZSA+IG9sZFBsYXlsaXN0LnRpbWVsaW5lIHx8IG9sZFBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCAmJiBwbGF5bGlzdC50aW1lbGluZSA+IG9sZFBsYXlsaXN0LnNlZ21lbnRzW29sZFBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCAtIDFdLnRpbWVsaW5lKSB7XG4gICAgICAgIHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTZXF1ZW5jZS0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGUgZmlyc3Qgc2VnbWVudCBtYXRjaGVkIHdpdGggYSBwcmlvciBzZWdtZW50IG9uIGEgZGlzY29udGludWl0eSAoaXQncyBtYXRjaGluZ1xuICAgIC8vIG9uIHRoZSBmaXJzdCBzZWdtZW50IG9mIGEgcGVyaW9kKSwgdGhlbiB0aGUgZGlzY29udGludWl0eVNlcXVlbmNlIHNob3VsZG4ndCBiZSB0aGVcbiAgICAvLyB0aW1lbGluZSdzIG1hdGNoaW5nIG9uZSwgYnV0IGluc3RlYWQgc2hvdWxkIGJlIHRoZSBvbmUgcHJpb3IsIGFuZCB0aGUgZmlyc3Qgc2VnbWVudFxuICAgIC8vIG9mIHRoZSBuZXcgbWFuaWZlc3Qgc2hvdWxkIGJlIG1hcmtlZCB3aXRoIGEgZGlzY29udGludWl0eS5cbiAgICAvL1xuICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgc3BlY2lhbCBjYXNlIGlzIHRoYXQgZGlzY29udGludWl0eSBzZXF1ZW5jZSBzaG93cyBob3cgbWFueVxuICAgIC8vIGRpc2NvbnRpbnVpdGllcyBoYXZlIGZhbGxlbiBvZmYgb2YgdGhlIHBsYXlsaXN0LCBhbmQgZGlzY29udGludWl0aWVzIGFyZSBtYXJrZWQgb25cbiAgICAvLyB0aGUgZmlyc3Qgc2VnbWVudCBvZiBhIG5ldyBcInRpbWVsaW5lLlwiIEJlY2F1c2Ugb2YgdGhpcywgd2hpbGUgREFTSCB3aWxsIHJldGFpbiB0aGF0XG4gICAgLy8gUGVyaW9kIHdoaWxlIHRoZSBcInRpbWVsaW5lXCIgZXhpc3RzLCBITFMga2VlcHMgdHJhY2sgb2YgaXQgdmlhIHRoZSBkaXNjb250aW51aXR5XG4gICAgLy8gc2VxdWVuY2UsIGFuZCB0aGF0IGZpcnN0IHNlZ21lbnQgaXMgYW4gaW5kaWNhdG9yLCBidXQgY2FuIGJlIHJlbW92ZWQgYmVmb3JlIHRoYXRcbiAgICAvLyB0aW1lbGluZSBpcyBnb25lLlxuXG5cbiAgICBjb25zdCBvbGRNYXRjaGluZ1NlZ21lbnQgPSBvbGRQbGF5bGlzdC5zZWdtZW50c1tvbGRNYXRjaGluZ1NlZ21lbnRJbmRleF07XG5cbiAgICBpZiAob2xkTWF0Y2hpbmdTZWdtZW50LmRpc2NvbnRpbnVpdHkgJiYgIWZpcnN0TmV3U2VnbWVudC5kaXNjb250aW51aXR5KSB7XG4gICAgICBmaXJzdE5ld1NlZ21lbnQuZGlzY29udGludWl0eSA9IHRydWU7XG4gICAgICBwbGF5bGlzdC5kaXNjb250aW51aXR5U3RhcnRzLnVuc2hpZnQoMCk7XG4gICAgICBwbGF5bGlzdC5kaXNjb250aW51aXR5U2VxdWVuY2UtLTtcbiAgICB9XG5cbiAgICB1cGRhdGVNZWRpYVNlcXVlbmNlRm9yUGxheWxpc3Qoe1xuICAgICAgcGxheWxpc3QsXG4gICAgICBtZWRpYVNlcXVlbmNlOiBvbGRQbGF5bGlzdC5zZWdtZW50c1tvbGRNYXRjaGluZ1NlZ21lbnRJbmRleF0ubnVtYmVyXG4gICAgfSk7XG4gIH0pO1xufTtcbi8qKlxuICogR2l2ZW4gYW4gb2xkIHBhcnNlZCBtYW5pZmVzdCBvYmplY3QgYW5kIGEgbmV3IHBhcnNlZCBtYW5pZmVzdCBvYmplY3QsIHVwZGF0ZXMgdGhlXG4gKiBzZXF1ZW5jZSBhbmQgdGltaW5nIHZhbHVlcyB3aXRoaW4gdGhlIG5ldyBtYW5pZmVzdCB0byBlbnN1cmUgdGhhdCBpdCBsaW5lcyB1cCB3aXRoIHRoZVxuICogb2xkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG9sZE1hbmlmZXN0IC0gdGhlIG9sZCBtYWluIG1hbmlmZXN0IG9iamVjdFxuICogQHBhcmFtIHtBcnJheX0gbmV3TWFuaWZlc3QgLSB0aGUgbmV3IG1haW4gbWFuaWZlc3Qgb2JqZWN0XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgdXBkYXRlZCBuZXcgbWFuaWZlc3Qgb2JqZWN0XG4gKi9cblxuY29uc3QgcG9zaXRpb25NYW5pZmVzdE9uVGltZWxpbmUgPSAoe1xuICBvbGRNYW5pZmVzdCxcbiAgbmV3TWFuaWZlc3Rcbn0pID0+IHtcbiAgLy8gU3RhcnRpbmcgZnJvbSB2NC4xLjIgb2YgdGhlIElPUCwgc2VjdGlvbiA0LjQuMy4zIHN0YXRlczpcbiAgLy9cbiAgLy8gXCJNUERAYXZhaWxhYmlsaXR5U3RhcnRUaW1lIGFuZCBQZXJpb2RAc3RhcnQgc2hhbGwgbm90IGJlIGNoYW5nZWQgb3ZlciBNUEQgdXBkYXRlcy5cIlxuICAvL1xuICAvLyBUaGlzIHdhcyBhZGRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL0RBU0gtSUYtSU9QL2lzc3Vlcy8xNjBcbiAgLy9cbiAgLy8gQmVjYXVzZSBvZiB0aGlzIGNoYW5nZSwgYW5kIHRoZSBkaWZmaWN1bHR5IG9mIHN1cHBvcnRpbmcgcGVyaW9kcyB3aXRoIGNoYW5naW5nIHN0YXJ0XG4gIC8vIHRpbWVzLCBwZXJpb2RzIHdpdGggY2hhbmdpbmcgc3RhcnQgdGltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuIFRoaXMgbWFrZXMgdGhlIGxvZ2ljIG11Y2hcbiAgLy8gc2ltcGxlciwgc2luY2UgcGVyaW9kcyB3aXRoIHRoZSBzYW1lIHN0YXJ0IHRpbWUgY2FuIGJlIGNvbnNpZGVycmVkIHRoZSBzYW1lIHBlcmlvZFxuICAvLyBhY3Jvc3MgcmVmcmVzaGVzLlxuICAvL1xuICAvLyBUbyBnaXZlIGFuIGV4YW1wbGUgYXMgdG8gdGhlIGRpZmZpY3VsdHkgb2YgaGFuZGxpbmcgcGVyaW9kcyB3aGVyZSB0aGUgc3RhcnQgdGltZSBtYXlcbiAgLy8gY2hhbmdlLCBpZiBhIHNpbmdsZSBwZXJpb2QgbWFuaWZlc3QgaXMgcmVmcmVzaGVkIHdpdGggYW5vdGhlciBtYW5pZmVzdCB3aXRoIGEgc2luZ2xlXG4gIC8vIHBlcmlvZCwgYW5kIGJvdGggdGhlIHN0YXJ0IGFuZCBlbmQgdGltZXMgYXJlIGluY3JlYXNlZCwgdGhlbiB0aGUgb25seSB3YXkgdG8gZGV0ZXJtaW5lXG4gIC8vIGlmIGl0J3MgYSBuZXcgcGVyaW9kIG9yIGFuIG9sZCBvbmUgdGhhdCBoYXMgY2hhbmdlZCBpcyB0byBsb29rIHRocm91Z2ggdGhlIHNlZ21lbnRzIG9mXG4gIC8vIGVhY2ggcGxheWxpc3QgYW5kIGRldGVybWluZSB0aGUgcHJlc2VudGF0aW9uIHRpbWUgYm91bmRzIHRvIGZpbmQgYSBtYXRjaC4gSW4gYWRkaXRpb24sXG4gIC8vIGlmIHRoZSBwZXJpb2Qgc3RhcnQgY2hhbmdlZCB0byBleGNlZWQgdGhlIG9sZCBwZXJpb2QgZW5kLCB0aGVuIHRoZXJlIHdvdWxkIGJlIG5vXG4gIC8vIG1hdGNoLCBhbmQgaXQgd291bGQgbm90IGJlIHBvc3NpYmxlIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSByZWZyZXNoZWQgcGVyaW9kIGlzIGEgbmV3XG4gIC8vIG9uZSBvciB0aGUgb2xkIG9uZS5cbiAgY29uc3Qgb2xkUGxheWxpc3RzID0gb2xkTWFuaWZlc3QucGxheWxpc3RzLmNvbmNhdChnZXRNZWRpYUdyb3VwUGxheWxpc3RzKG9sZE1hbmlmZXN0KSk7XG4gIGNvbnN0IG5ld1BsYXlsaXN0cyA9IG5ld01hbmlmZXN0LnBsYXlsaXN0cy5jb25jYXQoZ2V0TWVkaWFHcm91cFBsYXlsaXN0cyhuZXdNYW5pZmVzdCkpOyAvLyBTYXZlIGFsbCBzZWVuIHRpbWVsaW5lU3RhcnRzIHRvIHRoZSBuZXcgbWFuaWZlc3QuIEFsdGhvdWdoIHRoaXMgcG90ZW50aWFsbHkgbWVhbnMgdGhhdFxuICAvLyB0aGVyZSdzIGEgXCJtZW1vcnkgbGVha1wiIGluIHRoYXQgaXQgd2lsbCBuZXZlciBzdG9wIGdyb3dpbmcsIGluIHJlYWxpdHksIG9ubHkgYSBjb3VwbGVcbiAgLy8gb2YgcHJvcGVydGllcyBhcmUgc2F2ZWQgZm9yIGVhY2ggc2VlbiBQZXJpb2QuIEV2ZW4gbG9uZyBydW5uaW5nIGxpdmUgc3RyZWFtcyB3b24ndFxuICAvLyBnZW5lcmF0ZSB0b28gbWFueSBQZXJpb2RzLCB1bmxlc3MgdGhlIHN0cmVhbSBpcyB3YXRjaGVkIGZvciBkZWNhZGVzLiBJbiB0aGUgZnV0dXJlLFxuICAvLyB0aGlzIGNhbiBiZSBvcHRpbWl6ZWQgYnkgbWFwcGluZyB0byBkaXNjb250aW51aXR5IHNlcXVlbmNlIG51bWJlcnMgZm9yIGVhY2ggdGltZWxpbmUsXG4gIC8vIGJ1dCBpdCBtYXkgbm90IGJlY29tZSBhbiBpc3N1ZSwgYW5kIHRoZSBhZGRpdGlvbmFsIGluZm8gY2FuIGJlIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuXG4gIG5ld01hbmlmZXN0LnRpbWVsaW5lU3RhcnRzID0gZ2V0VW5pcXVlVGltZWxpbmVTdGFydHMoW29sZE1hbmlmZXN0LnRpbWVsaW5lU3RhcnRzLCBuZXdNYW5pZmVzdC50aW1lbGluZVN0YXJ0c10pO1xuICB1cGRhdGVTZXF1ZW5jZU51bWJlcnMoe1xuICAgIG9sZFBsYXlsaXN0cyxcbiAgICBuZXdQbGF5bGlzdHMsXG4gICAgdGltZWxpbmVTdGFydHM6IG5ld01hbmlmZXN0LnRpbWVsaW5lU3RhcnRzXG4gIH0pO1xuICByZXR1cm4gbmV3TWFuaWZlc3Q7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVNpZHhLZXkgPSBzaWR4ID0+IHNpZHggJiYgc2lkeC51cmkgKyAnLScgKyBieXRlUmFuZ2VUb1N0cmluZyhzaWR4LmJ5dGVyYW5nZSk7XG5cbmNvbnN0IG1lcmdlRGlzY29udGlndW91c1BsYXlsaXN0cyA9IHBsYXlsaXN0cyA9PiB7XG4gIC8vIEJyZWFrIG91dCBwbGF5bGlzdHMgaW50byBncm91cHMgYmFzZWQgb24gdGhlaXIgYmFzZVVybFxuICBjb25zdCBwbGF5bGlzdHNCeUJhc2VVcmwgPSBwbGF5bGlzdHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cikge1xuICAgIGlmICghYWNjW2N1ci5hdHRyaWJ1dGVzLmJhc2VVcmxdKSB7XG4gICAgICBhY2NbY3VyLmF0dHJpYnV0ZXMuYmFzZVVybF0gPSBbXTtcbiAgICB9XG5cbiAgICBhY2NbY3VyLmF0dHJpYnV0ZXMuYmFzZVVybF0ucHVzaChjdXIpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgbGV0IGFsbFBsYXlsaXN0cyA9IFtdO1xuICBPYmplY3QudmFsdWVzKHBsYXlsaXN0c0J5QmFzZVVybCkuZm9yRWFjaChwbGF5bGlzdEdyb3VwID0+IHtcbiAgICBjb25zdCBtZXJnZWRQbGF5bGlzdHMgPSB2YWx1ZXMocGxheWxpc3RHcm91cC5yZWR1Y2UoKGFjYywgcGxheWxpc3QpID0+IHtcbiAgICAgIC8vIGFzc3VtaW5nIHBsYXlsaXN0IElEcyBhcmUgdGhlIHNhbWUgYWNyb3NzIHBlcmlvZHNcbiAgICAgIC8vIFRPRE86IGhhbmRsZSBtdWx0aXBlcmlvZCB3aGVyZSByZXByZXNlbnRhdGlvbiBzZXRzIGFyZSBub3QgdGhlIHNhbWVcbiAgICAgIC8vIGFjcm9zcyBwZXJpb2RzXG4gICAgICBjb25zdCBuYW1lID0gcGxheWxpc3QuYXR0cmlidXRlcy5pZCArIChwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhbmcgfHwgJycpO1xuXG4gICAgICBpZiAoIWFjY1tuYW1lXSkge1xuICAgICAgICAvLyBGaXJzdCBQZXJpb2RcbiAgICAgICAgYWNjW25hbWVdID0gcGxheWxpc3Q7XG4gICAgICAgIGFjY1tuYW1lXS5hdHRyaWJ1dGVzLnRpbWVsaW5lU3RhcnRzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdWJzZXF1ZW50IFBlcmlvZHNcbiAgICAgICAgaWYgKHBsYXlsaXN0LnNlZ21lbnRzKSB7XG4gICAgICAgICAgLy8gZmlyc3Qgc2VnbWVudCBvZiBzdWJzZXF1ZW50IHBlcmlvZHMgc2lnbmFsIGEgZGlzY29udGludWl0eVxuICAgICAgICAgIGlmIChwbGF5bGlzdC5zZWdtZW50c1swXSkge1xuICAgICAgICAgICAgcGxheWxpc3Quc2VnbWVudHNbMF0uZGlzY29udGludWl0eSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWNjW25hbWVdLnNlZ21lbnRzLnB1c2goLi4ucGxheWxpc3Quc2VnbWVudHMpO1xuICAgICAgICB9IC8vIGJ1YmJsZSB1cCBjb250ZW50UHJvdGVjdGlvbiwgdGhpcyBhc3N1bWVzIGFsbCBEUk0gY29udGVudFxuICAgICAgICAvLyBoYXMgdGhlIHNhbWUgY29udGVudFByb3RlY3Rpb25cblxuXG4gICAgICAgIGlmIChwbGF5bGlzdC5hdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uKSB7XG4gICAgICAgICAgYWNjW25hbWVdLmF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb24gPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFjY1tuYW1lXS5hdHRyaWJ1dGVzLnRpbWVsaW5lU3RhcnRzLnB1c2goe1xuICAgICAgICAvLyBBbHRob3VnaCB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBudW1iZXIsIGl0J3MgaW1wb3J0YW50IHRvIGhhdmUgYm90aCB0byBtYWtlIGl0XG4gICAgICAgIC8vIGNvbXBhdGlibGUgd2l0aCBITFMgcG90ZW50aWFsbHkgaGF2aW5nIGEgc2ltaWxhciBhdHRyaWJ1dGUuXG4gICAgICAgIHN0YXJ0OiBwbGF5bGlzdC5hdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0LFxuICAgICAgICB0aW1lbGluZTogcGxheWxpc3QuYXR0cmlidXRlcy5wZXJpb2RTdGFydFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KSk7XG4gICAgYWxsUGxheWxpc3RzID0gYWxsUGxheWxpc3RzLmNvbmNhdChtZXJnZWRQbGF5bGlzdHMpO1xuICB9KTtcbiAgcmV0dXJuIGFsbFBsYXlsaXN0cy5tYXAocGxheWxpc3QgPT4ge1xuICAgIHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTdGFydHMgPSBmaW5kSW5kZXhlcyhwbGF5bGlzdC5zZWdtZW50cyB8fCBbXSwgJ2Rpc2NvbnRpbnVpdHknKTtcbiAgICByZXR1cm4gcGxheWxpc3Q7XG4gIH0pO1xufTtcblxuY29uc3QgYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCA9IChwbGF5bGlzdCwgc2lkeE1hcHBpbmcpID0+IHtcbiAgY29uc3Qgc2lkeEtleSA9IGdlbmVyYXRlU2lkeEtleShwbGF5bGlzdC5zaWR4KTtcbiAgY29uc3Qgc2lkeE1hdGNoID0gc2lkeEtleSAmJiBzaWR4TWFwcGluZ1tzaWR4S2V5XSAmJiBzaWR4TWFwcGluZ1tzaWR4S2V5XS5zaWR4O1xuXG4gIGlmIChzaWR4TWF0Y2gpIHtcbiAgICBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0JDEocGxheWxpc3QsIHNpZHhNYXRjaCwgcGxheWxpc3Quc2lkeC5yZXNvbHZlZFVyaSk7XG4gIH1cblxuICByZXR1cm4gcGxheWxpc3Q7XG59O1xuY29uc3QgYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdHMgPSAocGxheWxpc3RzLCBzaWR4TWFwcGluZyA9IHt9KSA9PiB7XG4gIGlmICghT2JqZWN0LmtleXMoc2lkeE1hcHBpbmcpLmxlbmd0aCkge1xuICAgIHJldHVybiBwbGF5bGlzdHM7XG4gIH1cblxuICBmb3IgKGNvbnN0IGkgaW4gcGxheWxpc3RzKSB7XG4gICAgcGxheWxpc3RzW2ldID0gYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdChwbGF5bGlzdHNbaV0sIHNpZHhNYXBwaW5nKTtcbiAgfVxuXG4gIHJldHVybiBwbGF5bGlzdHM7XG59O1xuY29uc3QgZm9ybWF0QXVkaW9QbGF5bGlzdCA9ICh7XG4gIGF0dHJpYnV0ZXMsXG4gIHNlZ21lbnRzLFxuICBzaWR4LFxuICBtZWRpYVNlcXVlbmNlLFxuICBkaXNjb250aW51aXR5U2VxdWVuY2UsXG4gIGRpc2NvbnRpbnVpdHlTdGFydHNcbn0sIGlzQXVkaW9Pbmx5KSA9PiB7XG4gIGNvbnN0IHBsYXlsaXN0ID0ge1xuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIE5BTUU6IGF0dHJpYnV0ZXMuaWQsXG4gICAgICBCQU5EV0lEVEg6IGF0dHJpYnV0ZXMuYmFuZHdpZHRoLFxuICAgICAgQ09ERUNTOiBhdHRyaWJ1dGVzLmNvZGVjcyxcbiAgICAgIFsnUFJPR1JBTS1JRCddOiAxXG4gICAgfSxcbiAgICB1cmk6ICcnLFxuICAgIGVuZExpc3Q6IGF0dHJpYnV0ZXMudHlwZSA9PT0gJ3N0YXRpYycsXG4gICAgdGltZWxpbmU6IGF0dHJpYnV0ZXMucGVyaW9kU3RhcnQsXG4gICAgcmVzb2x2ZWRVcmk6IGF0dHJpYnV0ZXMuYmFzZVVybCB8fCAnJyxcbiAgICB0YXJnZXREdXJhdGlvbjogYXR0cmlidXRlcy5kdXJhdGlvbixcbiAgICBkaXNjb250aW51aXR5U2VxdWVuY2UsXG4gICAgZGlzY29udGludWl0eVN0YXJ0cyxcbiAgICB0aW1lbGluZVN0YXJ0czogYXR0cmlidXRlcy50aW1lbGluZVN0YXJ0cyxcbiAgICBtZWRpYVNlcXVlbmNlLFxuICAgIHNlZ21lbnRzXG4gIH07XG5cbiAgaWYgKGF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb24pIHtcbiAgICBwbGF5bGlzdC5jb250ZW50UHJvdGVjdGlvbiA9IGF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb247XG4gIH1cblxuICBpZiAoYXR0cmlidXRlcy5zZXJ2aWNlTG9jYXRpb24pIHtcbiAgICBwbGF5bGlzdC5hdHRyaWJ1dGVzLnNlcnZpY2VMb2NhdGlvbiA9IGF0dHJpYnV0ZXMuc2VydmljZUxvY2F0aW9uO1xuICB9XG5cbiAgaWYgKHNpZHgpIHtcbiAgICBwbGF5bGlzdC5zaWR4ID0gc2lkeDtcbiAgfVxuXG4gIGlmIChpc0F1ZGlvT25seSkge1xuICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXMuQVVESU8gPSAnYXVkaW8nO1xuICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXMuU1VCVElUTEVTID0gJ3N1YnMnO1xuICB9XG5cbiAgcmV0dXJuIHBsYXlsaXN0O1xufTtcbmNvbnN0IGZvcm1hdFZ0dFBsYXlsaXN0ID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgc2VnbWVudHMsXG4gIG1lZGlhU2VxdWVuY2UsXG4gIGRpc2NvbnRpbnVpdHlTdGFydHMsXG4gIGRpc2NvbnRpbnVpdHlTZXF1ZW5jZVxufSkgPT4ge1xuICBpZiAodHlwZW9mIHNlZ21lbnRzID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHZ0dCB0cmFja3MgbWF5IHVzZSBzaW5nbGUgZmlsZSBpbiBCYXNlVVJMXG4gICAgc2VnbWVudHMgPSBbe1xuICAgICAgdXJpOiBhdHRyaWJ1dGVzLmJhc2VVcmwsXG4gICAgICB0aW1lbGluZTogYXR0cmlidXRlcy5wZXJpb2RTdGFydCxcbiAgICAgIHJlc29sdmVkVXJpOiBhdHRyaWJ1dGVzLmJhc2VVcmwgfHwgJycsXG4gICAgICBkdXJhdGlvbjogYXR0cmlidXRlcy5zb3VyY2VEdXJhdGlvbixcbiAgICAgIG51bWJlcjogMFxuICAgIH1dOyAvLyB0YXJnZXREdXJhdGlvbiBzaG91bGQgYmUgdGhlIHNhbWUgZHVyYXRpb24gYXMgdGhlIG9ubHkgc2VnbWVudFxuXG4gICAgYXR0cmlidXRlcy5kdXJhdGlvbiA9IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb247XG4gIH1cblxuICBjb25zdCBtM3U4QXR0cmlidXRlcyA9IHtcbiAgICBOQU1FOiBhdHRyaWJ1dGVzLmlkLFxuICAgIEJBTkRXSURUSDogYXR0cmlidXRlcy5iYW5kd2lkdGgsXG4gICAgWydQUk9HUkFNLUlEJ106IDFcbiAgfTtcblxuICBpZiAoYXR0cmlidXRlcy5jb2RlY3MpIHtcbiAgICBtM3U4QXR0cmlidXRlcy5DT0RFQ1MgPSBhdHRyaWJ1dGVzLmNvZGVjcztcbiAgfVxuXG4gIGNvbnN0IHZ0dFBsYXlsaXN0ID0ge1xuICAgIGF0dHJpYnV0ZXM6IG0zdThBdHRyaWJ1dGVzLFxuICAgIHVyaTogJycsXG4gICAgZW5kTGlzdDogYXR0cmlidXRlcy50eXBlID09PSAnc3RhdGljJyxcbiAgICB0aW1lbGluZTogYXR0cmlidXRlcy5wZXJpb2RTdGFydCxcbiAgICByZXNvbHZlZFVyaTogYXR0cmlidXRlcy5iYXNlVXJsIHx8ICcnLFxuICAgIHRhcmdldER1cmF0aW9uOiBhdHRyaWJ1dGVzLmR1cmF0aW9uLFxuICAgIHRpbWVsaW5lU3RhcnRzOiBhdHRyaWJ1dGVzLnRpbWVsaW5lU3RhcnRzLFxuICAgIGRpc2NvbnRpbnVpdHlTdGFydHMsXG4gICAgZGlzY29udGludWl0eVNlcXVlbmNlLFxuICAgIG1lZGlhU2VxdWVuY2UsXG4gICAgc2VnbWVudHNcbiAgfTtcblxuICBpZiAoYXR0cmlidXRlcy5zZXJ2aWNlTG9jYXRpb24pIHtcbiAgICB2dHRQbGF5bGlzdC5hdHRyaWJ1dGVzLnNlcnZpY2VMb2NhdGlvbiA9IGF0dHJpYnV0ZXMuc2VydmljZUxvY2F0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHZ0dFBsYXlsaXN0O1xufTtcbmNvbnN0IG9yZ2FuaXplQXVkaW9QbGF5bGlzdHMgPSAocGxheWxpc3RzLCBzaWR4TWFwcGluZyA9IHt9LCBpc0F1ZGlvT25seSA9IGZhbHNlKSA9PiB7XG4gIGxldCBtYWluUGxheWxpc3Q7XG4gIGNvbnN0IGZvcm1hdHRlZFBsYXlsaXN0cyA9IHBsYXlsaXN0cy5yZWR1Y2UoKGEsIHBsYXlsaXN0KSA9PiB7XG4gICAgY29uc3Qgcm9sZSA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMucm9sZSAmJiBwbGF5bGlzdC5hdHRyaWJ1dGVzLnJvbGUudmFsdWUgfHwgJyc7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhbmcgfHwgJyc7XG4gICAgbGV0IGxhYmVsID0gcGxheWxpc3QuYXR0cmlidXRlcy5sYWJlbCB8fCAnbWFpbic7XG5cbiAgICBpZiAobGFuZ3VhZ2UgJiYgIXBsYXlsaXN0LmF0dHJpYnV0ZXMubGFiZWwpIHtcbiAgICAgIGNvbnN0IHJvbGVMYWJlbCA9IHJvbGUgPyBgICgke3JvbGV9KWAgOiAnJztcbiAgICAgIGxhYmVsID0gYCR7cGxheWxpc3QuYXR0cmlidXRlcy5sYW5nfSR7cm9sZUxhYmVsfWA7XG4gICAgfVxuXG4gICAgaWYgKCFhW2xhYmVsXSkge1xuICAgICAgYVtsYWJlbF0gPSB7XG4gICAgICAgIGxhbmd1YWdlLFxuICAgICAgICBhdXRvc2VsZWN0OiB0cnVlLFxuICAgICAgICBkZWZhdWx0OiByb2xlID09PSAnbWFpbicsXG4gICAgICAgIHBsYXlsaXN0czogW10sXG4gICAgICAgIHVyaTogJydcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0dGVkID0gYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdChmb3JtYXRBdWRpb1BsYXlsaXN0KHBsYXlsaXN0LCBpc0F1ZGlvT25seSksIHNpZHhNYXBwaW5nKTtcbiAgICBhW2xhYmVsXS5wbGF5bGlzdHMucHVzaChmb3JtYXR0ZWQpO1xuXG4gICAgaWYgKHR5cGVvZiBtYWluUGxheWxpc3QgPT09ICd1bmRlZmluZWQnICYmIHJvbGUgPT09ICdtYWluJykge1xuICAgICAgbWFpblBsYXlsaXN0ID0gcGxheWxpc3Q7XG4gICAgICBtYWluUGxheWxpc3QuZGVmYXVsdCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KTsgLy8gaWYgbm8gcGxheWxpc3RzIGhhdmUgcm9sZSBcIm1haW5cIiwgbWFyayB0aGUgZmlyc3QgYXMgbWFpblxuXG4gIGlmICghbWFpblBsYXlsaXN0KSB7XG4gICAgY29uc3QgZmlyc3RMYWJlbCA9IE9iamVjdC5rZXlzKGZvcm1hdHRlZFBsYXlsaXN0cylbMF07XG4gICAgZm9ybWF0dGVkUGxheWxpc3RzW2ZpcnN0TGFiZWxdLmRlZmF1bHQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdHRlZFBsYXlsaXN0cztcbn07XG5jb25zdCBvcmdhbml6ZVZ0dFBsYXlsaXN0cyA9IChwbGF5bGlzdHMsIHNpZHhNYXBwaW5nID0ge30pID0+IHtcbiAgcmV0dXJuIHBsYXlsaXN0cy5yZWR1Y2UoKGEsIHBsYXlsaXN0KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhYmVsIHx8IHBsYXlsaXN0LmF0dHJpYnV0ZXMubGFuZyB8fCAndGV4dCc7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhbmcgfHwgJ3VuZCc7XG5cbiAgICBpZiAoIWFbbGFiZWxdKSB7XG4gICAgICBhW2xhYmVsXSA9IHtcbiAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBhdXRvc2VsZWN0OiBmYWxzZSxcbiAgICAgICAgcGxheWxpc3RzOiBbXSxcbiAgICAgICAgdXJpOiAnJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBhW2xhYmVsXS5wbGF5bGlzdHMucHVzaChhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0KGZvcm1hdFZ0dFBsYXlsaXN0KHBsYXlsaXN0KSwgc2lkeE1hcHBpbmcpKTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufTtcblxuY29uc3Qgb3JnYW5pemVDYXB0aW9uU2VydmljZXMgPSBjYXB0aW9uU2VydmljZXMgPT4gY2FwdGlvblNlcnZpY2VzLnJlZHVjZSgoc3ZjT2JqLCBzdmMpID0+IHtcbiAgaWYgKCFzdmMpIHtcbiAgICByZXR1cm4gc3ZjT2JqO1xuICB9XG5cbiAgc3ZjLmZvckVhY2goc2VydmljZSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2hhbm5lbCxcbiAgICAgIGxhbmd1YWdlXG4gICAgfSA9IHNlcnZpY2U7XG4gICAgc3ZjT2JqW2xhbmd1YWdlXSA9IHtcbiAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBpbnN0cmVhbUlkOiBjaGFubmVsLFxuICAgICAgbGFuZ3VhZ2VcbiAgICB9O1xuXG4gICAgaWYgKHNlcnZpY2UuaGFzT3duUHJvcGVydHkoJ2FzcGVjdFJhdGlvJykpIHtcbiAgICAgIHN2Y09ialtsYW5ndWFnZV0uYXNwZWN0UmF0aW8gPSBzZXJ2aWNlLmFzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIGlmIChzZXJ2aWNlLmhhc093blByb3BlcnR5KCdlYXN5UmVhZGVyJykpIHtcbiAgICAgIHN2Y09ialtsYW5ndWFnZV0uZWFzeVJlYWRlciA9IHNlcnZpY2UuZWFzeVJlYWRlcjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmljZS5oYXNPd25Qcm9wZXJ0eSgnM0QnKSkge1xuICAgICAgc3ZjT2JqW2xhbmd1YWdlXVsnM0QnXSA9IHNlcnZpY2VbJzNEJ107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN2Y09iajtcbn0sIHt9KTtcblxuY29uc3QgZm9ybWF0VmlkZW9QbGF5bGlzdCA9ICh7XG4gIGF0dHJpYnV0ZXMsXG4gIHNlZ21lbnRzLFxuICBzaWR4LFxuICBkaXNjb250aW51aXR5U3RhcnRzXG59KSA9PiB7XG4gIGNvbnN0IHBsYXlsaXN0ID0ge1xuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIE5BTUU6IGF0dHJpYnV0ZXMuaWQsXG4gICAgICBBVURJTzogJ2F1ZGlvJyxcbiAgICAgIFNVQlRJVExFUzogJ3N1YnMnLFxuICAgICAgUkVTT0xVVElPTjoge1xuICAgICAgICB3aWR0aDogYXR0cmlidXRlcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBhdHRyaWJ1dGVzLmhlaWdodFxuICAgICAgfSxcbiAgICAgIENPREVDUzogYXR0cmlidXRlcy5jb2RlY3MsXG4gICAgICBCQU5EV0lEVEg6IGF0dHJpYnV0ZXMuYmFuZHdpZHRoLFxuICAgICAgWydQUk9HUkFNLUlEJ106IDFcbiAgICB9LFxuICAgIHVyaTogJycsXG4gICAgZW5kTGlzdDogYXR0cmlidXRlcy50eXBlID09PSAnc3RhdGljJyxcbiAgICB0aW1lbGluZTogYXR0cmlidXRlcy5wZXJpb2RTdGFydCxcbiAgICByZXNvbHZlZFVyaTogYXR0cmlidXRlcy5iYXNlVXJsIHx8ICcnLFxuICAgIHRhcmdldER1cmF0aW9uOiBhdHRyaWJ1dGVzLmR1cmF0aW9uLFxuICAgIGRpc2NvbnRpbnVpdHlTdGFydHMsXG4gICAgdGltZWxpbmVTdGFydHM6IGF0dHJpYnV0ZXMudGltZWxpbmVTdGFydHMsXG4gICAgc2VnbWVudHNcbiAgfTtcblxuICBpZiAoYXR0cmlidXRlcy5mcmFtZVJhdGUpIHtcbiAgICBwbGF5bGlzdC5hdHRyaWJ1dGVzWydGUkFNRS1SQVRFJ10gPSBhdHRyaWJ1dGVzLmZyYW1lUmF0ZTtcbiAgfVxuXG4gIGlmIChhdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uKSB7XG4gICAgcGxheWxpc3QuY29udGVudFByb3RlY3Rpb24gPSBhdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uO1xuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXMuc2VydmljZUxvY2F0aW9uKSB7XG4gICAgcGxheWxpc3QuYXR0cmlidXRlcy5zZXJ2aWNlTG9jYXRpb24gPSBhdHRyaWJ1dGVzLnNlcnZpY2VMb2NhdGlvbjtcbiAgfVxuXG4gIGlmIChzaWR4KSB7XG4gICAgcGxheWxpc3Quc2lkeCA9IHNpZHg7XG4gIH1cblxuICByZXR1cm4gcGxheWxpc3Q7XG59O1xuXG5jb25zdCB2aWRlb09ubHkgPSAoe1xuICBhdHRyaWJ1dGVzXG59KSA9PiBhdHRyaWJ1dGVzLm1pbWVUeXBlID09PSAndmlkZW8vbXA0JyB8fCBhdHRyaWJ1dGVzLm1pbWVUeXBlID09PSAndmlkZW8vd2VibScgfHwgYXR0cmlidXRlcy5jb250ZW50VHlwZSA9PT0gJ3ZpZGVvJztcblxuY29uc3QgYXVkaW9Pbmx5ID0gKHtcbiAgYXR0cmlidXRlc1xufSkgPT4gYXR0cmlidXRlcy5taW1lVHlwZSA9PT0gJ2F1ZGlvL21wNCcgfHwgYXR0cmlidXRlcy5taW1lVHlwZSA9PT0gJ2F1ZGlvL3dlYm0nIHx8IGF0dHJpYnV0ZXMuY29udGVudFR5cGUgPT09ICdhdWRpbyc7XG5cbmNvbnN0IHZ0dE9ubHkgPSAoe1xuICBhdHRyaWJ1dGVzXG59KSA9PiBhdHRyaWJ1dGVzLm1pbWVUeXBlID09PSAndGV4dC92dHQnIHx8IGF0dHJpYnV0ZXMuY29udGVudFR5cGUgPT09ICd0ZXh0Jztcbi8qKlxuICogQ29udGFpbnMgc3RhcnQgYW5kIHRpbWVsaW5lIHByb3BlcnRpZXMgZGVub3RpbmcgYSB0aW1lbGluZSBzdGFydC4gRm9yIERBU0gsIHRoZXNlIHdpbGxcbiAqIGJlIHRoZSBzYW1lIG51bWJlci5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaW1lbGluZVN0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnQgLSB0aGUgc3RhcnQgdGltZSBvZiB0aGUgdGltZWxpbmVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lbGluZSAtIHRoZSB0aW1lbGluZSBudW1iZXJcbiAqL1xuXG4vKipcbiAqIEFkZHMgYXBwcm9wcmlhdGUgbWVkaWEgYW5kIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdmFsdWVzIHRvIHRoZSBzZWdtZW50cyBhbmQgcGxheWxpc3RzLlxuICpcbiAqIFRocm91Z2hvdXQgbXBkLXBhcnNlciwgdGhlIGBudW1iZXJgIGF0dHJpYnV0ZSBpcyB1c2VkIGluIHJlbGF0aW9uIHRvIGBzdGFydE51bWJlcmAsIGFcbiAqIERBU0ggc3BlY2lmaWMgYXR0cmlidXRlIHVzZWQgaW4gY29uc3RydWN0aW5nIHNlZ21lbnQgVVJJJ3MgZnJvbSB0ZW1wbGF0ZXMuIEhvd2V2ZXIsIGZyb21cbiAqIGFuIEhMUyBwZXJzcGVjdGl2ZSwgdGhlIGBudW1iZXJgIGF0dHJpYnV0ZSBvbiBhIHNlZ21lbnQgd291bGQgYmUgaXRzIGBtZWRpYVNlcXVlbmNlYFxuICogdmFsdWUsIHdoaWNoIHNob3VsZCBzdGFydCBhdCB0aGUgb3JpZ2luYWwgbWVkaWEgc2VxdWVuY2UgdmFsdWUgKG9yIDApIGFuZCBpbmNyZW1lbnQgYnkgMVxuICogZm9yIGVhY2ggc2VnbWVudCB0aGVyZWFmdGVyLiBTaW5jZSBEQVNIJ3MgYHN0YXJ0TnVtYmVyYCB2YWx1ZXMgYXJlIGluZGVwZW5kZW50IHBlclxuICogcGVyaW9kLCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gdXNlIGl0IGZvciBgbnVtYmVyYC4gSW5zdGVhZCwgYXNzdW1lIGV2ZXJ5dGhpbmcgc3RhcnRzXG4gKiBmcm9tIGEgMCBtZWRpYVNlcXVlbmNlIHZhbHVlIGFuZCBpbmNyZW1lbnQgZnJvbSB0aGVyZS5cbiAqXG4gKiBOb3RlIHRoYXQgVkhTIGN1cnJlbnRseSBkb2Vzbid0IHVzZSB0aGUgYG51bWJlcmAgcHJvcGVydHksIGJ1dCBpdCBjYW4gYmUgaGVscGZ1bCBmb3JcbiAqIGRlYnVnZ2luZyBhbmQgbWFraW5nIHNlbnNlIG9mIHRoZSBtYW5pZmVzdC5cbiAqXG4gKiBGb3IgbGl2ZSBwbGF5bGlzdHMsIHRvIGFjY291bnQgZm9yIHZhbHVlcyBpbmNyZWFzaW5nIGluIG1hbmlmZXN0cyB3aGVuIHBlcmlvZHMgYXJlXG4gKiByZW1vdmVkIG9uIHJlZnJlc2hlcywgbWVyZ2luZyBsb2dpYyBzaG91bGQgYmUgdXNlZCB0byB1cGRhdGUgdGhlIG51bWJlcnMgdG8gdGhlaXJcbiAqIGFwcHJvcHJpYXRlIHZhbHVlcyAodG8gZW5zdXJlIHRoZXkncmUgc2VxdWVudGlhbCBhbmQgaW5jcmVhc2luZykuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gcGxheWxpc3RzIC0gdGhlIHBsYXlsaXN0cyB0byB1cGRhdGVcbiAqIEBwYXJhbSB7VGltZWxpbmVTdGFydFtdfSB0aW1lbGluZVN0YXJ0cyAtIHRoZSB0aW1lbGluZSBzdGFydHMgZm9yIHRoZSBtYW5pZmVzdFxuICovXG5cblxuY29uc3QgYWRkTWVkaWFTZXF1ZW5jZVZhbHVlcyA9IChwbGF5bGlzdHMsIHRpbWVsaW5lU3RhcnRzKSA9PiB7XG4gIC8vIGluY3JlbWVudCBhbGwgc2VnbWVudHMgc2VxdWVudGlhbGx5XG4gIHBsYXlsaXN0cy5mb3JFYWNoKHBsYXlsaXN0ID0+IHtcbiAgICBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlID0gMDtcbiAgICBwbGF5bGlzdC5kaXNjb250aW51aXR5U2VxdWVuY2UgPSB0aW1lbGluZVN0YXJ0cy5maW5kSW5kZXgoZnVuY3Rpb24gKHtcbiAgICAgIHRpbWVsaW5lXG4gICAgfSkge1xuICAgICAgcmV0dXJuIHRpbWVsaW5lID09PSBwbGF5bGlzdC50aW1lbGluZTtcbiAgICB9KTtcblxuICAgIGlmICghcGxheWxpc3Quc2VnbWVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbGF5bGlzdC5zZWdtZW50cy5mb3JFYWNoKChzZWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgc2VnbWVudC5udW1iZXIgPSBpbmRleDtcbiAgICB9KTtcbiAgfSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIG1lZGlhIGdyb3VwIG9iamVjdCwgZmxhdHRlbnMgYWxsIHBsYXlsaXN0cyB3aXRoaW4gdGhlIG1lZGlhIGdyb3VwIGludG8gYSBzaW5nbGVcbiAqIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZWRpYUdyb3VwT2JqZWN0IC0gdGhlIG1lZGlhIGdyb3VwIG9iamVjdFxuICpcbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICogICAgICAgICBUaGUgbWVkaWEgZ3JvdXAgcGxheWxpc3RzXG4gKi9cblxuY29uc3QgZmxhdHRlbk1lZGlhR3JvdXBQbGF5bGlzdHMgPSBtZWRpYUdyb3VwT2JqZWN0ID0+IHtcbiAgaWYgKCFtZWRpYUdyb3VwT2JqZWN0KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lZGlhR3JvdXBPYmplY3QpLnJlZHVjZSgoYWNjLCBsYWJlbCkgPT4ge1xuICAgIGNvbnN0IGxhYmVsQ29udGVudHMgPSBtZWRpYUdyb3VwT2JqZWN0W2xhYmVsXTtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChsYWJlbENvbnRlbnRzLnBsYXlsaXN0cyk7XG4gIH0sIFtdKTtcbn07XG5jb25zdCB0b00zdTggPSAoe1xuICBkYXNoUGxheWxpc3RzLFxuICBsb2NhdGlvbnMsXG4gIGNvbnRlbnRTdGVlcmluZyxcbiAgc2lkeE1hcHBpbmcgPSB7fSxcbiAgcHJldmlvdXNNYW5pZmVzdCxcbiAgZXZlbnRTdHJlYW1cbn0pID0+IHtcbiAgaWYgKCFkYXNoUGxheWxpc3RzLmxlbmd0aCkge1xuICAgIHJldHVybiB7fTtcbiAgfSAvLyBncmFiIGFsbCBtYWluIG1hbmlmZXN0IGF0dHJpYnV0ZXNcblxuXG4gIGNvbnN0IHtcbiAgICBzb3VyY2VEdXJhdGlvbjogZHVyYXRpb24sXG4gICAgdHlwZSxcbiAgICBzdWdnZXN0ZWRQcmVzZW50YXRpb25EZWxheSxcbiAgICBtaW5pbXVtVXBkYXRlUGVyaW9kXG4gIH0gPSBkYXNoUGxheWxpc3RzWzBdLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IHZpZGVvUGxheWxpc3RzID0gbWVyZ2VEaXNjb250aWd1b3VzUGxheWxpc3RzKGRhc2hQbGF5bGlzdHMuZmlsdGVyKHZpZGVvT25seSkpLm1hcChmb3JtYXRWaWRlb1BsYXlsaXN0KTtcbiAgY29uc3QgYXVkaW9QbGF5bGlzdHMgPSBtZXJnZURpc2NvbnRpZ3VvdXNQbGF5bGlzdHMoZGFzaFBsYXlsaXN0cy5maWx0ZXIoYXVkaW9Pbmx5KSk7XG4gIGNvbnN0IHZ0dFBsYXlsaXN0cyA9IG1lcmdlRGlzY29udGlndW91c1BsYXlsaXN0cyhkYXNoUGxheWxpc3RzLmZpbHRlcih2dHRPbmx5KSk7XG4gIGNvbnN0IGNhcHRpb25zID0gZGFzaFBsYXlsaXN0cy5tYXAocGxheWxpc3QgPT4gcGxheWxpc3QuYXR0cmlidXRlcy5jYXB0aW9uU2VydmljZXMpLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgbWFuaWZlc3QgPSB7XG4gICAgYWxsb3dDYWNoZTogdHJ1ZSxcbiAgICBkaXNjb250aW51aXR5U3RhcnRzOiBbXSxcbiAgICBzZWdtZW50czogW10sXG4gICAgZW5kTGlzdDogdHJ1ZSxcbiAgICBtZWRpYUdyb3Vwczoge1xuICAgICAgQVVESU86IHt9LFxuICAgICAgVklERU86IHt9LFxuICAgICAgWydDTE9TRUQtQ0FQVElPTlMnXToge30sXG4gICAgICBTVUJUSVRMRVM6IHt9XG4gICAgfSxcbiAgICB1cmk6ICcnLFxuICAgIGR1cmF0aW9uLFxuICAgIHBsYXlsaXN0czogYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdHModmlkZW9QbGF5bGlzdHMsIHNpZHhNYXBwaW5nKVxuICB9O1xuXG4gIGlmIChtaW5pbXVtVXBkYXRlUGVyaW9kID49IDApIHtcbiAgICBtYW5pZmVzdC5taW5pbXVtVXBkYXRlUGVyaW9kID0gbWluaW11bVVwZGF0ZVBlcmlvZCAqIDEwMDA7XG4gIH1cblxuICBpZiAobG9jYXRpb25zKSB7XG4gICAgbWFuaWZlc3QubG9jYXRpb25zID0gbG9jYXRpb25zO1xuICB9XG5cbiAgaWYgKGNvbnRlbnRTdGVlcmluZykge1xuICAgIG1hbmlmZXN0LmNvbnRlbnRTdGVlcmluZyA9IGNvbnRlbnRTdGVlcmluZztcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnZHluYW1pYycpIHtcbiAgICBtYW5pZmVzdC5zdWdnZXN0ZWRQcmVzZW50YXRpb25EZWxheSA9IHN1Z2dlc3RlZFByZXNlbnRhdGlvbkRlbGF5O1xuICB9XG5cbiAgaWYgKGV2ZW50U3RyZWFtICYmIGV2ZW50U3RyZWFtLmxlbmd0aCA+IDApIHtcbiAgICBtYW5pZmVzdC5ldmVudFN0cmVhbSA9IGV2ZW50U3RyZWFtO1xuICB9XG5cbiAgY29uc3QgaXNBdWRpb09ubHkgPSBtYW5pZmVzdC5wbGF5bGlzdHMubGVuZ3RoID09PSAwO1xuICBjb25zdCBvcmdhbml6ZWRBdWRpb0dyb3VwID0gYXVkaW9QbGF5bGlzdHMubGVuZ3RoID8gb3JnYW5pemVBdWRpb1BsYXlsaXN0cyhhdWRpb1BsYXlsaXN0cywgc2lkeE1hcHBpbmcsIGlzQXVkaW9Pbmx5KSA6IG51bGw7XG4gIGNvbnN0IG9yZ2FuaXplZFZ0dEdyb3VwID0gdnR0UGxheWxpc3RzLmxlbmd0aCA/IG9yZ2FuaXplVnR0UGxheWxpc3RzKHZ0dFBsYXlsaXN0cywgc2lkeE1hcHBpbmcpIDogbnVsbDtcbiAgY29uc3QgZm9ybWF0dGVkUGxheWxpc3RzID0gdmlkZW9QbGF5bGlzdHMuY29uY2F0KGZsYXR0ZW5NZWRpYUdyb3VwUGxheWxpc3RzKG9yZ2FuaXplZEF1ZGlvR3JvdXApLCBmbGF0dGVuTWVkaWFHcm91cFBsYXlsaXN0cyhvcmdhbml6ZWRWdHRHcm91cCkpO1xuICBjb25zdCBwbGF5bGlzdFRpbWVsaW5lU3RhcnRzID0gZm9ybWF0dGVkUGxheWxpc3RzLm1hcCgoe1xuICAgIHRpbWVsaW5lU3RhcnRzXG4gIH0pID0+IHRpbWVsaW5lU3RhcnRzKTtcbiAgbWFuaWZlc3QudGltZWxpbmVTdGFydHMgPSBnZXRVbmlxdWVUaW1lbGluZVN0YXJ0cyhwbGF5bGlzdFRpbWVsaW5lU3RhcnRzKTtcbiAgYWRkTWVkaWFTZXF1ZW5jZVZhbHVlcyhmb3JtYXR0ZWRQbGF5bGlzdHMsIG1hbmlmZXN0LnRpbWVsaW5lU3RhcnRzKTtcblxuICBpZiAob3JnYW5pemVkQXVkaW9Hcm91cCkge1xuICAgIG1hbmlmZXN0Lm1lZGlhR3JvdXBzLkFVRElPLmF1ZGlvID0gb3JnYW5pemVkQXVkaW9Hcm91cDtcbiAgfVxuXG4gIGlmIChvcmdhbml6ZWRWdHRHcm91cCkge1xuICAgIG1hbmlmZXN0Lm1lZGlhR3JvdXBzLlNVQlRJVExFUy5zdWJzID0gb3JnYW5pemVkVnR0R3JvdXA7XG4gIH1cblxuICBpZiAoY2FwdGlvbnMubGVuZ3RoKSB7XG4gICAgbWFuaWZlc3QubWVkaWFHcm91cHNbJ0NMT1NFRC1DQVBUSU9OUyddLmNjID0gb3JnYW5pemVDYXB0aW9uU2VydmljZXMoY2FwdGlvbnMpO1xuICB9XG5cbiAgaWYgKHByZXZpb3VzTWFuaWZlc3QpIHtcbiAgICByZXR1cm4gcG9zaXRpb25NYW5pZmVzdE9uVGltZWxpbmUoe1xuICAgICAgb2xkTWFuaWZlc3Q6IHByZXZpb3VzTWFuaWZlc3QsXG4gICAgICBuZXdNYW5pZmVzdDogbWFuaWZlc3RcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBtYW5pZmVzdDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgUiAocmVwZXRpdGlvbikgdmFsdWUgZm9yIGEgbGl2ZSBzdHJlYW0gKGZvciB0aGUgZmluYWwgc2VnbWVudFxuICogaW4gYSBtYW5pZmVzdCB3aGVyZSB0aGUgciB2YWx1ZSBpcyBuZWdhdGl2ZSAxKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgYWxsIGluaGVyaXRlZCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50IGVsZW1lbnRzIHdpdGggYXR0cmlidXRlXG4gKiAgICAgICAgbmFtZXMgYXMga2V5c1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqICAgICAgICBjdXJyZW50IHRpbWUgKHR5cGljYWxseSB0aGUgdG90YWwgdGltZSB1cCB1bnRpbCB0aGUgZmluYWwgc2VnbWVudClcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICogICAgICAgIGR1cmF0aW9uIHByb3BlcnR5IGZvciB0aGUgZ2l2ZW4gPFMgLz5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgUiB2YWx1ZSB0byByZWFjaCB0aGUgZW5kIG9mIHRoZSBnaXZlbiBwZXJpb2RcbiAqL1xuY29uc3QgZ2V0TGl2ZVJWYWx1ZSA9IChhdHRyaWJ1dGVzLCB0aW1lLCBkdXJhdGlvbikgPT4ge1xuICBjb25zdCB7XG4gICAgTk9XLFxuICAgIGNsaWVudE9mZnNldCxcbiAgICBhdmFpbGFiaWxpdHlTdGFydFRpbWUsXG4gICAgdGltZXNjYWxlID0gMSxcbiAgICBwZXJpb2RTdGFydCA9IDAsXG4gICAgbWluaW11bVVwZGF0ZVBlcmlvZCA9IDBcbiAgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IG5vdyA9IChOT1cgKyBjbGllbnRPZmZzZXQpIC8gMTAwMDtcbiAgY29uc3QgcGVyaW9kU3RhcnRXQyA9IGF2YWlsYWJpbGl0eVN0YXJ0VGltZSArIHBlcmlvZFN0YXJ0O1xuICBjb25zdCBwZXJpb2RFbmRXQyA9IG5vdyArIG1pbmltdW1VcGRhdGVQZXJpb2Q7XG4gIGNvbnN0IHBlcmlvZER1cmF0aW9uID0gcGVyaW9kRW5kV0MgLSBwZXJpb2RTdGFydFdDO1xuICByZXR1cm4gTWF0aC5jZWlsKChwZXJpb2REdXJhdGlvbiAqIHRpbWVzY2FsZSAtIHRpbWUpIC8gZHVyYXRpb24pO1xufTtcbi8qKlxuICogVXNlcyBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSBTZWdtZW50VGVtcGxhdGUuU2VnbWVudFRpbWVsaW5lIHRvIGRldGVybWluZSBzZWdtZW50XG4gKiB0aW1pbmcgYW5kIGR1cmF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgICAgICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBzZWdtZW50VGltZWxpbmVcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGVzIG9mIGVhY2ggUyBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW5cbiAqXG4gKiBAcmV0dXJuIHt7bnVtYmVyOiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXIsIHRpbWU6IG51bWJlciwgdGltZWxpbmU6IG51bWJlcn1bXX1cbiAqICAgICAgICAgTGlzdCBvZiBPYmplY3RzIHdpdGggc2VnbWVudCB0aW1pbmcgYW5kIGR1cmF0aW9uIGluZm9cbiAqL1xuXG5cbmNvbnN0IHBhcnNlQnlUaW1lbGluZSA9IChhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpID0+IHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgbWluaW11bVVwZGF0ZVBlcmlvZCA9IDAsXG4gICAgbWVkaWEgPSAnJyxcbiAgICBzb3VyY2VEdXJhdGlvbixcbiAgICB0aW1lc2NhbGUgPSAxLFxuICAgIHN0YXJ0TnVtYmVyID0gMSxcbiAgICBwZXJpb2RTdGFydDogdGltZWxpbmVcbiAgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IHNlZ21lbnRzID0gW107XG4gIGxldCB0aW1lID0gLTE7XG5cbiAgZm9yIChsZXQgc0luZGV4ID0gMDsgc0luZGV4IDwgc2VnbWVudFRpbWVsaW5lLmxlbmd0aDsgc0luZGV4KyspIHtcbiAgICBjb25zdCBTID0gc2VnbWVudFRpbWVsaW5lW3NJbmRleF07XG4gICAgY29uc3QgZHVyYXRpb24gPSBTLmQ7XG4gICAgY29uc3QgcmVwZWF0ID0gUy5yIHx8IDA7XG4gICAgY29uc3Qgc2VnbWVudFRpbWUgPSBTLnQgfHwgMDtcblxuICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgLy8gZmlyc3Qgc2VnbWVudFxuICAgICAgdGltZSA9IHNlZ21lbnRUaW1lO1xuICAgIH1cblxuICAgIGlmIChzZWdtZW50VGltZSAmJiBzZWdtZW50VGltZSA+IHRpbWUpIHtcbiAgICAgIC8vIGRpc2NvbnRpbnVpdHlcbiAgICAgIC8vIFRPRE86IEhvdyB0byBoYW5kbGUgdGhpcyB0eXBlIG9mIGRpc2NvbnRpbnVpdHlcbiAgICAgIC8vIHRpbWVsaW5lKysgaGVyZSB3b3VsZCB0cmVhdCBpdCBsaWtlIEhMUyBkaXNjb250dWl0eSBhbmQgY29udGVudCB3b3VsZFxuICAgICAgLy8gZ2V0IGFwcGVuZGVkIHdpdGhvdXQgZ2FwXG4gICAgICAvLyBFLkcuXG4gICAgICAvLyAgPFMgdD1cIjBcIiBkPVwiMVwiIC8+XG4gICAgICAvLyAgPFMgZD1cIjFcIiAvPlxuICAgICAgLy8gIDxTIGQ9XCIxXCIgLz5cbiAgICAgIC8vICA8UyB0PVwiNVwiIGQ9XCIxXCIgLz5cbiAgICAgIC8vIHdvdWxkIGhhdmUgJFRpbWUkIHZhbHVlcyBvZiBbMCwgMSwgMiwgNV1cbiAgICAgIC8vIHNob3VsZCB0aGlzIGJlIGFwcGVuZWQgYXQgdGltZSBwb3NpdGlvbnMgWzAsIDEsIDIsIDNdLCgjRVhULVgtRElTQ09OVElOVUlUWSlcbiAgICAgIC8vIG9yIFswLCAxLCAyLCBnYXAsIGdhcCwgNV0/ICgjRVhULVgtR0FQKVxuICAgICAgLy8gZG9lcyB0aGUgdmFsdWUgb2Ygc291cmNlRHVyYXRpb24gY29uc2lkZXIgdGhpcyB3aGVuIGNhbGN1bGF0aW5nIGFyYml0cmFyeVxuICAgICAgLy8gbmVnYXRpdmUgQHIgcmVwZWF0IHZhbHVlP1xuICAgICAgLy8gRS5HLiBTYW1lIGVsZW1lbnRzIGFzIGFib3ZlIHdpdGggdGhpcyBhZGRlZCBhdCB0aGUgZW5kXG4gICAgICAvLyAgPFMgZD1cIjFcIiByPVwiLTFcIiAvPlxuICAgICAgLy8gIHdpdGggYSBzb3VyY2VEdXJhdGlvbiBvZiAxMFxuICAgICAgLy8gV291bGQgdGhlIDIgZ2FwcyBiZSBpbmNsdWRlZCBpbiB0aGUgdGltZSBkdXJhdGlvbiBjYWxjdWxhdGlvbnMgcmVzdWx0aW5nIGluXG4gICAgICAvLyA4IHNlZ21lbnRzIHdpdGggJFRpbWUkIHZhbHVlcyBvZiBbMCwgMSwgMiwgNSwgNiwgNywgOCwgOV0gb3IgMTAgc2VnbWVudHNcbiAgICAgIC8vIHdpdGggJFRpbWUkIHZhbHVlcyBvZiBbMCwgMSwgMiwgNSwgNiwgNywgOCwgOSwgMTAsIDExXSA/XG4gICAgICB0aW1lID0gc2VnbWVudFRpbWU7XG4gICAgfVxuXG4gICAgbGV0IGNvdW50O1xuXG4gICAgaWYgKHJlcGVhdCA8IDApIHtcbiAgICAgIGNvbnN0IG5leHRTID0gc0luZGV4ICsgMTtcblxuICAgICAgaWYgKG5leHRTID09PSBzZWdtZW50VGltZWxpbmUubGVuZ3RoKSB7XG4gICAgICAgIC8vIGxhc3Qgc2VnbWVudFxuICAgICAgICBpZiAodHlwZSA9PT0gJ2R5bmFtaWMnICYmIG1pbmltdW1VcGRhdGVQZXJpb2QgPiAwICYmIG1lZGlhLmluZGV4T2YoJyROdW1iZXIkJykgPiAwKSB7XG4gICAgICAgICAgY291bnQgPSBnZXRMaXZlUlZhbHVlKGF0dHJpYnV0ZXMsIHRpbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIG1heSBiZSBpbmNvcnJlY3QgZGVwZW5kaW5nIG9uIGNvbmNsdXNpb24gb2YgVE9ETyBhYm92ZVxuICAgICAgICAgIGNvdW50ID0gKHNvdXJjZUR1cmF0aW9uICogdGltZXNjYWxlIC0gdGltZSkgLyBkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY291bnQgPSAoc2VnbWVudFRpbWVsaW5lW25leHRTXS50IC0gdGltZSkgLyBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSByZXBlYXQgKyAxO1xuICAgIH1cblxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0TnVtYmVyICsgc2VnbWVudHMubGVuZ3RoICsgY291bnQ7XG4gICAgbGV0IG51bWJlciA9IHN0YXJ0TnVtYmVyICsgc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG51bWJlciA8IGVuZCkge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIG51bWJlcixcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgICAgICB0aW1lLFxuICAgICAgICB0aW1lbGluZVxuICAgICAgfSk7XG4gICAgICB0aW1lICs9IGR1cmF0aW9uO1xuICAgICAgbnVtYmVyKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzO1xufTtcblxuY29uc3QgaWRlbnRpZmllclBhdHRlcm4gPSAvXFwkKFtBLXpdKikoPzooJTApKFswLTldKylkKT9cXCQvZztcbi8qKlxuICogUmVwbGFjZXMgdGVtcGxhdGUgaWRlbnRpZmllcnMgd2l0aCBjb3JyZXNwb25kaW5nIHZhbHVlcy4gVG8gYmUgdXNlZCBhcyB0aGUgY2FsbGJhY2tcbiAqIGZvciBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAqXG4gKiBAbmFtZSByZXBsYWNlQ2FsbGJhY2tcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoXG4gKiAgICAgICAgRW50aXJlIG1hdGNoIG9mIGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyXG4gKiAgICAgICAgTmFtZSBvZiBtYXRjaGVkIGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXRcbiAqICAgICAgICBGb3JtYXQgdGFnIHN0cmluZy4gSXRzIHByZXNlbmNlIGluZGljYXRlcyB0aGF0IHBhZGRpbmcgaXMgZXhwZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aFxuICogICAgICAgIERlc2lyZWQgbGVuZ3RoIG9mIHRoZSByZXBsYWNlZCB2YWx1ZS4gVmFsdWVzIGxlc3MgdGhhbiB0aGlzIHdpZHRoIHNoYWxsIGJlIGxlZnRcbiAqICAgICAgICB6ZXJvIHBhZGRlZFxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBSZXBsYWNlbWVudCBmb3IgdGhlIG1hdGNoZWQgaWRlbnRpZmllclxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgYXMgYSBjYWxsYmFjayBmb3IgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIHRvIHJlcGxhY2VcbiAqIHRlbXBsYXRlIGlkZW50aWZpZXJzXG4gKlxuICogQHBhcmFtIHtPYmVjdH0gdmFsdWVzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgdmFsdWVzIHRoYXQgc2hhbGwgYmUgdXNlZCB0byByZXBsYWNlIGtub3duIGlkZW50aWZpZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLlJlcHJlc2VudGF0aW9uSURcbiAqICAgICAgICBWYWx1ZSBvZiB0aGUgUmVwcmVzZW50YXRpb25AaWQgYXR0cmlidXRlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLk51bWJlclxuICogICAgICAgIE51bWJlciBvZiB0aGUgY29ycmVzcG9uZGluZyBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLkJhbmR3aWR0aFxuICogICAgICAgIFZhbHVlIG9mIHRoZSBSZXByZXNlbnRhdGlvbkBiYW5kd2lkdGggYXR0cmlidXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5UaW1lXG4gKiAgICAgICAgVGltZXN0YW1wIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIHNlZ21lbnRcbiAqIEByZXR1cm4ge3JlcGxhY2VDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgdG8gYmUgdXNlZCB3aXRoIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSB0byByZXBsYWNlIGlkZW50aWZpZXJzXG4gKi9cblxuY29uc3QgaWRlbnRpZmllclJlcGxhY2VtZW50ID0gdmFsdWVzID0+IChtYXRjaCwgaWRlbnRpZmllciwgZm9ybWF0LCB3aWR0aCkgPT4ge1xuICBpZiAobWF0Y2ggPT09ICckJCcpIHtcbiAgICAvLyBlc2NhcGUgc2VxdWVuY2VcbiAgICByZXR1cm4gJyQnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZXNbaWRlbnRpZmllcl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG1hdGNoO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSAnJyArIHZhbHVlc1tpZGVudGlmaWVyXTtcblxuICBpZiAoaWRlbnRpZmllciA9PT0gJ1JlcHJlc2VudGF0aW9uSUQnKSB7XG4gICAgLy8gRm9ybWF0IHRhZyBzaGFsbCBub3QgYmUgcHJlc2VudCB3aXRoIFJlcHJlc2VudGF0aW9uSURcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoIWZvcm1hdCkge1xuICAgIHdpZHRoID0gMTtcbiAgfSBlbHNlIHtcbiAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG4gIH1cblxuICBpZiAodmFsdWUubGVuZ3RoID49IHdpZHRoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGAke25ldyBBcnJheSh3aWR0aCAtIHZhbHVlLmxlbmd0aCArIDEpLmpvaW4oJzAnKX0ke3ZhbHVlfWA7XG59O1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgc2VnbWVudCB1cmwgZnJvbSBhIHRlbXBsYXRlIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqICAgICAgICBUZW1wbGF0ZSBzdHJpbmcgdG8gY29uc3RydWN0IHVybCBmcm9tXG4gKiBAcGFyYW0ge09iZWN0fSB2YWx1ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyB2YWx1ZXMgdGhhdCBzaGFsbCBiZSB1c2VkIHRvIHJlcGxhY2Uga25vd24gaWRlbnRpZmllcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuUmVwcmVzZW50YXRpb25JRFxuICogICAgICAgIFZhbHVlIG9mIHRoZSBSZXByZXNlbnRhdGlvbkBpZCBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuTnVtYmVyXG4gKiAgICAgICAgTnVtYmVyIG9mIHRoZSBjb3JyZXNwb25kaW5nIHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuQmFuZHdpZHRoXG4gKiAgICAgICAgVmFsdWUgb2YgdGhlIFJlcHJlc2VudGF0aW9uQGJhbmR3aWR0aCBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLlRpbWVcbiAqICAgICAgICBUaW1lc3RhbXAgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgc2VnbWVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBTZWdtZW50IHVybCB3aXRoIGlkZW50aWZpZXJzIHJlcGxhY2VkXG4gKi9cblxuY29uc3QgY29uc3RydWN0VGVtcGxhdGVVcmwgPSAodXJsLCB2YWx1ZXMpID0+IHVybC5yZXBsYWNlKGlkZW50aWZpZXJQYXR0ZXJuLCBpZGVudGlmaWVyUmVwbGFjZW1lbnQodmFsdWVzKSk7XG4vKipcbiAqIEdlbmVyYXRlcyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRpbWluZyBhbmQgZHVyYXRpb24gaW5mb3JtYXRpb24gYWJvdXQgZWFjaFxuICogc2VnbWVudCBuZWVkZWQgdG8gZ2VuZXJhdGUgc2VnbWVudCB1cmlzIGFuZCB0aGUgY29tcGxldGUgc2VnbWVudCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICAgICAgIG5hbWVzIGFzIGtleXNcbiAqIEBwYXJhbSB7T2JqZWN0W118dW5kZWZpbmVkfSBzZWdtZW50VGltZWxpbmVcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGVzIG9mIGVhY2ggUyBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW5cbiAqICAgICAgICB0aGUgU2VnbWVudFRpbWVsaW5lIGVsZW1lbnRcbiAqIEByZXR1cm4ge3tudW1iZXI6IG51bWJlciwgZHVyYXRpb246IG51bWJlciwgdGltZTogbnVtYmVyLCB0aW1lbGluZTogbnVtYmVyfVtdfVxuICogICAgICAgICBMaXN0IG9mIE9iamVjdHMgd2l0aCBzZWdtZW50IHRpbWluZyBhbmQgZHVyYXRpb24gaW5mb1xuICovXG5cbmNvbnN0IHBhcnNlVGVtcGxhdGVJbmZvID0gKGF0dHJpYnV0ZXMsIHNlZ21lbnRUaW1lbGluZSkgPT4ge1xuICBpZiAoIWF0dHJpYnV0ZXMuZHVyYXRpb24gJiYgIXNlZ21lbnRUaW1lbGluZSkge1xuICAgIC8vIGlmIG5laXRoZXIgQGR1cmF0aW9uIG9yIFNlZ21lbnRUaW1lbGluZSBhcmUgcHJlc2VudCwgdGhlbiB0aGVyZSBzaGFsbCBiZSBleGFjdGx5XG4gICAgLy8gb25lIG1lZGlhIHNlZ21lbnRcbiAgICByZXR1cm4gW3tcbiAgICAgIG51bWJlcjogYXR0cmlidXRlcy5zdGFydE51bWJlciB8fCAxLFxuICAgICAgZHVyYXRpb246IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb24sXG4gICAgICB0aW1lOiAwLFxuICAgICAgdGltZWxpbmU6IGF0dHJpYnV0ZXMucGVyaW9kU3RhcnRcbiAgICB9XTtcbiAgfVxuXG4gIGlmIChhdHRyaWJ1dGVzLmR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHBhcnNlQnlEdXJhdGlvbihhdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUJ5VGltZWxpbmUoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKTtcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhIGxpc3Qgb2Ygc2VnbWVudHMgdXNpbmcgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkgdGhlIFNlZ21lbnRUZW1wbGF0ZSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgICAgICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdFtdfHVuZGVmaW5lZH0gc2VnbWVudFRpbWVsaW5lXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYXR0cmlidXRlcyBvZiBlYWNoIFMgZWxlbWVudCBjb250YWluZWQgd2l0aGluXG4gKiAgICAgICAgdGhlIFNlZ21lbnRUaW1lbGluZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqICAgICAgICAgTGlzdCBvZiBzZWdtZW50IG9iamVjdHNcbiAqL1xuXG5jb25zdCBzZWdtZW50c0Zyb21UZW1wbGF0ZSA9IChhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpID0+IHtcbiAgY29uc3QgdGVtcGxhdGVWYWx1ZXMgPSB7XG4gICAgUmVwcmVzZW50YXRpb25JRDogYXR0cmlidXRlcy5pZCxcbiAgICBCYW5kd2lkdGg6IGF0dHJpYnV0ZXMuYmFuZHdpZHRoIHx8IDBcbiAgfTtcbiAgY29uc3Qge1xuICAgIGluaXRpYWxpemF0aW9uID0ge1xuICAgICAgc291cmNlVVJMOiAnJyxcbiAgICAgIHJhbmdlOiAnJ1xuICAgIH1cbiAgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IG1hcFNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHtcbiAgICBiYXNlVXJsOiBhdHRyaWJ1dGVzLmJhc2VVcmwsXG4gICAgc291cmNlOiBjb25zdHJ1Y3RUZW1wbGF0ZVVybChpbml0aWFsaXphdGlvbi5zb3VyY2VVUkwsIHRlbXBsYXRlVmFsdWVzKSxcbiAgICByYW5nZTogaW5pdGlhbGl6YXRpb24ucmFuZ2VcbiAgfSk7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGFyc2VUZW1wbGF0ZUluZm8oYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKTtcbiAgcmV0dXJuIHNlZ21lbnRzLm1hcChzZWdtZW50ID0+IHtcbiAgICB0ZW1wbGF0ZVZhbHVlcy5OdW1iZXIgPSBzZWdtZW50Lm51bWJlcjtcbiAgICB0ZW1wbGF0ZVZhbHVlcy5UaW1lID0gc2VnbWVudC50aW1lO1xuICAgIGNvbnN0IHVyaSA9IGNvbnN0cnVjdFRlbXBsYXRlVXJsKGF0dHJpYnV0ZXMubWVkaWEgfHwgJycsIHRlbXBsYXRlVmFsdWVzKTsgLy8gU2VlIERBU0ggc3BlYyBzZWN0aW9uIDUuMy45LjIuMlxuICAgIC8vIC0gaWYgdGltZXNjYWxlIGlzbid0IHByZXNlbnQgb24gYW55IGxldmVsLCBkZWZhdWx0IHRvIDEuXG5cbiAgICBjb25zdCB0aW1lc2NhbGUgPSBhdHRyaWJ1dGVzLnRpbWVzY2FsZSB8fCAxOyAvLyAtIGlmIHByZXNlbnRhdGlvblRpbWVPZmZzZXQgaXNuJ3QgcHJlc2VudCBvbiBhbnkgbGV2ZWwsIGRlZmF1bHQgdG8gMFxuXG4gICAgY29uc3QgcHJlc2VudGF0aW9uVGltZU9mZnNldCA9IGF0dHJpYnV0ZXMucHJlc2VudGF0aW9uVGltZU9mZnNldCB8fCAwO1xuICAgIGNvbnN0IHByZXNlbnRhdGlvblRpbWUgPSAvLyBFdmVuIGlmIHRoZSBAdCBhdHRyaWJ1dGUgaXMgbm90IHNwZWNpZmllZCBmb3IgdGhlIHNlZ21lbnQsIHNlZ21lbnQudGltZSBpc1xuICAgIC8vIGNhbGN1bGF0ZWQgaW4gbXBkLXBhcnNlciBwcmlvciB0byB0aGlzLCBzbyBpdCdzIGFzc3VtZWQgdG8gYmUgYXZhaWxhYmxlLlxuICAgIGF0dHJpYnV0ZXMucGVyaW9kU3RhcnQgKyAoc2VnbWVudC50aW1lIC0gcHJlc2VudGF0aW9uVGltZU9mZnNldCkgLyB0aW1lc2NhbGU7XG4gICAgY29uc3QgbWFwID0ge1xuICAgICAgdXJpLFxuICAgICAgdGltZWxpbmU6IHNlZ21lbnQudGltZWxpbmUsXG4gICAgICBkdXJhdGlvbjogc2VnbWVudC5kdXJhdGlvbixcbiAgICAgIHJlc29sdmVkVXJpOiByZXNvbHZlVXJsKGF0dHJpYnV0ZXMuYmFzZVVybCB8fCAnJywgdXJpKSxcbiAgICAgIG1hcDogbWFwU2VnbWVudCxcbiAgICAgIG51bWJlcjogc2VnbWVudC5udW1iZXIsXG4gICAgICBwcmVzZW50YXRpb25UaW1lXG4gICAgfTtcbiAgICByZXR1cm4gbWFwO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSA8U2VnbWVudFVybD4gKG9mIHR5cGUgVVJMVHlwZSBmcm9tIHRoZSBEQVNIIHNwZWMgNS4zLjkuMiBUYWJsZSAxNClcbiAqIHRvIGFuIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIG91dHB1dCBvZiBhIHNlZ21lbnQgaW4gdmlkZW9qcy9tcGQtcGFyc2VyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgT2JqZWN0IGNvbnRhaW5pbmcgYWxsIGluaGVyaXRlZCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50IGVsZW1lbnRzIHdpdGggYXR0cmlidXRlXG4gKiAgIG5hbWVzIGFzIGtleXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50VXJsXG4gKiAgIDxTZWdtZW50VVJMPiBub2RlIHRvIHRyYW5zbGF0ZSBpbnRvIGEgc2VnbWVudCBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gdHJhbnNsYXRlZCBzZWdtZW50IG9iamVjdFxuICovXG5cbmNvbnN0IFNlZ21lbnRVUkxUb1NlZ21lbnRPYmplY3QgPSAoYXR0cmlidXRlcywgc2VnbWVudFVybCkgPT4ge1xuICBjb25zdCB7XG4gICAgYmFzZVVybCxcbiAgICBpbml0aWFsaXphdGlvbiA9IHt9XG4gIH0gPSBhdHRyaWJ1dGVzO1xuICBjb25zdCBpbml0U2VnbWVudCA9IHVybFR5cGVUb1NlZ21lbnQoe1xuICAgIGJhc2VVcmwsXG4gICAgc291cmNlOiBpbml0aWFsaXphdGlvbi5zb3VyY2VVUkwsXG4gICAgcmFuZ2U6IGluaXRpYWxpemF0aW9uLnJhbmdlXG4gIH0pO1xuICBjb25zdCBzZWdtZW50ID0gdXJsVHlwZVRvU2VnbWVudCh7XG4gICAgYmFzZVVybCxcbiAgICBzb3VyY2U6IHNlZ21lbnRVcmwubWVkaWEsXG4gICAgcmFuZ2U6IHNlZ21lbnRVcmwubWVkaWFSYW5nZVxuICB9KTtcbiAgc2VnbWVudC5tYXAgPSBpbml0U2VnbWVudDtcbiAgcmV0dXJuIHNlZ21lbnQ7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsaXN0IG9mIHNlZ21lbnRzIHVzaW5nIGluZm9ybWF0aW9uIHByb3ZpZGVkIGJ5IHRoZSBTZWdtZW50TGlzdCBlbGVtZW50XG4gKiBTZWdtZW50TGlzdCAoREFTSCBTUEVDIFNlY3Rpb24gNS4zLjkuMy4yKSBjb250YWlucyBhIHNldCBvZiA8U2VnbWVudFVSTD4gbm9kZXMuICBFYWNoXG4gKiBub2RlIHNob3VsZCBiZSB0cmFuc2xhdGVkIGludG8gc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgbmFtZXMgYXMga2V5c1xuICogQHBhcmFtIHtPYmplY3RbXXx1bmRlZmluZWR9IHNlZ21lbnRUaW1lbGluZVxuICogICAgICAgIExpc3Qgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZXMgb2YgZWFjaCBTIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpblxuICogICAgICAgIHRoZSBTZWdtZW50VGltZWxpbmUgZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0LjxBcnJheT59IGxpc3Qgb2Ygc2VnbWVudHNcbiAqL1xuXG5cbmNvbnN0IHNlZ21lbnRzRnJvbUxpc3QgPSAoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbixcbiAgICBzZWdtZW50VXJscyA9IFtdLFxuICAgIHBlcmlvZFN0YXJ0XG4gIH0gPSBhdHRyaWJ1dGVzOyAvLyBQZXIgc3BlYyAoNS4zLjkuMi4xKSBubyB3YXkgdG8gZGV0ZXJtaW5lIHNlZ21lbnQgZHVyYXRpb24gT1JcbiAgLy8gaWYgYm90aCBTZWdtZW50VGltZWxpbmUgYW5kIEBkdXJhdGlvbiBhcmUgZGVmaW5lZCwgaXQgaXMgb3V0c2lkZSBvZiBzcGVjLlxuXG4gIGlmICghZHVyYXRpb24gJiYgIXNlZ21lbnRUaW1lbGluZSB8fCBkdXJhdGlvbiAmJiBzZWdtZW50VGltZWxpbmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNFR01FTlRfVElNRV9VTlNQRUNJRklFRCk7XG4gIH1cblxuICBjb25zdCBzZWdtZW50VXJsTWFwID0gc2VnbWVudFVybHMubWFwKHNlZ21lbnRVcmxPYmplY3QgPT4gU2VnbWVudFVSTFRvU2VnbWVudE9iamVjdChhdHRyaWJ1dGVzLCBzZWdtZW50VXJsT2JqZWN0KSk7XG4gIGxldCBzZWdtZW50VGltZUluZm87XG5cbiAgaWYgKGR1cmF0aW9uKSB7XG4gICAgc2VnbWVudFRpbWVJbmZvID0gcGFyc2VCeUR1cmF0aW9uKGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgaWYgKHNlZ21lbnRUaW1lbGluZSkge1xuICAgIHNlZ21lbnRUaW1lSW5mbyA9IHBhcnNlQnlUaW1lbGluZShhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpO1xuICB9XG5cbiAgY29uc3Qgc2VnbWVudHMgPSBzZWdtZW50VGltZUluZm8ubWFwKChzZWdtZW50VGltZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoc2VnbWVudFVybE1hcFtpbmRleF0pIHtcbiAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50VXJsTWFwW2luZGV4XTsgLy8gU2VlIERBU0ggc3BlYyBzZWN0aW9uIDUuMy45LjIuMlxuICAgICAgLy8gLSBpZiB0aW1lc2NhbGUgaXNuJ3QgcHJlc2VudCBvbiBhbnkgbGV2ZWwsIGRlZmF1bHQgdG8gMS5cblxuICAgICAgY29uc3QgdGltZXNjYWxlID0gYXR0cmlidXRlcy50aW1lc2NhbGUgfHwgMTsgLy8gLSBpZiBwcmVzZW50YXRpb25UaW1lT2Zmc2V0IGlzbid0IHByZXNlbnQgb24gYW55IGxldmVsLCBkZWZhdWx0IHRvIDBcblxuICAgICAgY29uc3QgcHJlc2VudGF0aW9uVGltZU9mZnNldCA9IGF0dHJpYnV0ZXMucHJlc2VudGF0aW9uVGltZU9mZnNldCB8fCAwO1xuICAgICAgc2VnbWVudC50aW1lbGluZSA9IHNlZ21lbnRUaW1lLnRpbWVsaW5lO1xuICAgICAgc2VnbWVudC5kdXJhdGlvbiA9IHNlZ21lbnRUaW1lLmR1cmF0aW9uO1xuICAgICAgc2VnbWVudC5udW1iZXIgPSBzZWdtZW50VGltZS5udW1iZXI7XG4gICAgICBzZWdtZW50LnByZXNlbnRhdGlvblRpbWUgPSBwZXJpb2RTdGFydCArIChzZWdtZW50VGltZS50aW1lIC0gcHJlc2VudGF0aW9uVGltZU9mZnNldCkgLyB0aW1lc2NhbGU7XG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICB9IC8vIFNpbmNlIHdlJ3JlIG1hcHBpbmcgd2Ugc2hvdWxkIGdldCByaWQgb2YgYW55IGJsYW5rIHNlZ21lbnRzIChpbiBjYXNlXG4gICAgLy8gdGhlIGdpdmVuIFNlZ21lbnRUaW1lbGluZSBpcyBoYW5kbGluZyBmb3IgbW9yZSBlbGVtZW50cyB0aGFuIHdlIGhhdmVcbiAgICAvLyBTZWdtZW50VVJMcyBmb3IpLlxuXG4gIH0pLmZpbHRlcihzZWdtZW50ID0+IHNlZ21lbnQpO1xuICByZXR1cm4gc2VnbWVudHM7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVNlZ21lbnRzID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgc2VnbWVudEluZm9cbn0pID0+IHtcbiAgbGV0IHNlZ21lbnRBdHRyaWJ1dGVzO1xuICBsZXQgc2VnbWVudHNGbjtcblxuICBpZiAoc2VnbWVudEluZm8udGVtcGxhdGUpIHtcbiAgICBzZWdtZW50c0ZuID0gc2VnbWVudHNGcm9tVGVtcGxhdGU7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMgPSBtZXJnZShhdHRyaWJ1dGVzLCBzZWdtZW50SW5mby50ZW1wbGF0ZSk7XG4gIH0gZWxzZSBpZiAoc2VnbWVudEluZm8uYmFzZSkge1xuICAgIHNlZ21lbnRzRm4gPSBzZWdtZW50c0Zyb21CYXNlO1xuICAgIHNlZ21lbnRBdHRyaWJ1dGVzID0gbWVyZ2UoYXR0cmlidXRlcywgc2VnbWVudEluZm8uYmFzZSk7XG4gIH0gZWxzZSBpZiAoc2VnbWVudEluZm8ubGlzdCkge1xuICAgIHNlZ21lbnRzRm4gPSBzZWdtZW50c0Zyb21MaXN0O1xuICAgIHNlZ21lbnRBdHRyaWJ1dGVzID0gbWVyZ2UoYXR0cmlidXRlcywgc2VnbWVudEluZm8ubGlzdCk7XG4gIH1cblxuICBjb25zdCBzZWdtZW50c0luZm8gPSB7XG4gICAgYXR0cmlidXRlc1xuICB9O1xuXG4gIGlmICghc2VnbWVudHNGbikge1xuICAgIHJldHVybiBzZWdtZW50c0luZm87XG4gIH1cblxuICBjb25zdCBzZWdtZW50cyA9IHNlZ21lbnRzRm4oc2VnbWVudEF0dHJpYnV0ZXMsIHNlZ21lbnRJbmZvLnNlZ21lbnRUaW1lbGluZSk7IC8vIFRoZSBAZHVyYXRpb24gYXR0cmlidXRlIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbiB0aGUgcGxheWxpc3QncyB0YXJnZXREdXJhdGlvbiB3aGljaFxuICAvLyBtdXN0IGJlIGluIHNlY29uZHMuIFNpbmNlIHdlJ3ZlIGdlbmVyYXRlZCB0aGUgc2VnbWVudCBsaXN0LCB3ZSBubyBsb25nZXIgbmVlZFxuICAvLyBAZHVyYXRpb24gdG8gYmUgaW4gQHRpbWVzY2FsZSB1bml0cywgc28gd2UgY2FuIGNvbnZlcnQgaXQgaGVyZS5cblxuICBpZiAoc2VnbWVudEF0dHJpYnV0ZXMuZHVyYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBkdXJhdGlvbixcbiAgICAgIHRpbWVzY2FsZSA9IDFcbiAgICB9ID0gc2VnbWVudEF0dHJpYnV0ZXM7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMuZHVyYXRpb24gPSBkdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgfSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBAZHVyYXRpb24gYXR0cmlidXRlLCB1c2UgdGhlIGxhcmdlc3Qgc2VnbWVudCBkdXJhdGlvbiBhc1xuICAgIC8vIGFzIHRhcmdldCBkdXJhdGlvblxuICAgIHNlZ21lbnRBdHRyaWJ1dGVzLmR1cmF0aW9uID0gc2VnbWVudHMucmVkdWNlKChtYXgsIHNlZ21lbnQpID0+IHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIE1hdGguY2VpbChzZWdtZW50LmR1cmF0aW9uKSk7XG4gICAgfSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMuZHVyYXRpb24gPSAwO1xuICB9XG5cbiAgc2VnbWVudHNJbmZvLmF0dHJpYnV0ZXMgPSBzZWdtZW50QXR0cmlidXRlcztcbiAgc2VnbWVudHNJbmZvLnNlZ21lbnRzID0gc2VnbWVudHM7IC8vIFRoaXMgaXMgYSBzaWR4IGJveCB3aXRob3V0IGFjdHVhbCBzZWdtZW50IGluZm9ybWF0aW9uXG5cbiAgaWYgKHNlZ21lbnRJbmZvLmJhc2UgJiYgc2VnbWVudEF0dHJpYnV0ZXMuaW5kZXhSYW5nZSkge1xuICAgIHNlZ21lbnRzSW5mby5zaWR4ID0gc2VnbWVudHNbMF07XG4gICAgc2VnbWVudHNJbmZvLnNlZ21lbnRzID0gW107XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHNJbmZvO1xufTtcbmNvbnN0IHRvUGxheWxpc3RzID0gcmVwcmVzZW50YXRpb25zID0+IHJlcHJlc2VudGF0aW9ucy5tYXAoZ2VuZXJhdGVTZWdtZW50cyk7XG5cbmNvbnN0IGZpbmRDaGlsZHJlbiA9IChlbGVtZW50LCBuYW1lKSA9PiBmcm9tKGVsZW1lbnQuY2hpbGROb2RlcykuZmlsdGVyKCh7XG4gIHRhZ05hbWVcbn0pID0+IHRhZ05hbWUgPT09IG5hbWUpO1xuY29uc3QgZ2V0Q29udGVudCA9IGVsZW1lbnQgPT4gZWxlbWVudC50ZXh0Q29udGVudC50cmltKCk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIHN0cmluZyB0aGF0IG1heSBjb250YWluIGEgZGl2aXNpb24gb3BlcmF0aW9uIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBwcm92aWRlZCBzdHJpbmcgdmFsdWVcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBwYXJzZWQgc3RyaW5nIHZhbHVlXG4gKi9cbmNvbnN0IHBhcnNlRGl2aXNpb25WYWx1ZSA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUuc3BsaXQoJy8nKS5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHByZXYgLyBjdXJyZW50KSk7XG59O1xuXG5jb25zdCBwYXJzZUR1cmF0aW9uID0gc3RyID0+IHtcbiAgY29uc3QgU0VDT05EU19JTl9ZRUFSID0gMzY1ICogMjQgKiA2MCAqIDYwO1xuICBjb25zdCBTRUNPTkRTX0lOX01PTlRIID0gMzAgKiAyNCAqIDYwICogNjA7XG4gIGNvbnN0IFNFQ09ORFNfSU5fREFZID0gMjQgKiA2MCAqIDYwO1xuICBjb25zdCBTRUNPTkRTX0lOX0hPVVIgPSA2MCAqIDYwO1xuICBjb25zdCBTRUNPTkRTX0lOX01JTiA9IDYwOyAvLyBQMTBZMTBNMTBEVDEwSDEwTTEwLjFTXG5cbiAgY29uc3QgZHVyYXRpb25SZWdleCA9IC9QKD86KFxcZCopWSk/KD86KFxcZCopTSk/KD86KFxcZCopRCk/KD86VCg/OihcXGQqKUgpPyg/OihcXGQqKU0pPyg/OihbXFxkLl0qKVMpPyk/LztcbiAgY29uc3QgbWF0Y2ggPSBkdXJhdGlvblJlZ2V4LmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb25zdCBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmRdID0gbWF0Y2guc2xpY2UoMSk7XG4gIHJldHVybiBwYXJzZUZsb2F0KHllYXIgfHwgMCkgKiBTRUNPTkRTX0lOX1lFQVIgKyBwYXJzZUZsb2F0KG1vbnRoIHx8IDApICogU0VDT05EU19JTl9NT05USCArIHBhcnNlRmxvYXQoZGF5IHx8IDApICogU0VDT05EU19JTl9EQVkgKyBwYXJzZUZsb2F0KGhvdXIgfHwgMCkgKiBTRUNPTkRTX0lOX0hPVVIgKyBwYXJzZUZsb2F0KG1pbnV0ZSB8fCAwKSAqIFNFQ09ORFNfSU5fTUlOICsgcGFyc2VGbG9hdChzZWNvbmQgfHwgMCk7XG59O1xuY29uc3QgcGFyc2VEYXRlID0gc3RyID0+IHtcbiAgLy8gRGF0ZSBmb3JtYXQgd2l0aG91dCB0aW1lem9uZSBhY2NvcmRpbmcgdG8gSVNPIDg2MDFcbiAgLy8gWVlZLU1NLUREVGhoOm1tOnNzLnNzc3Nzc1xuICBjb25zdCBkYXRlUmVnZXggPSAvXlxcZCstXFxkKy1cXGQrVFxcZCs6XFxkKzpcXGQrKFxcLlxcZCspPyQvOyAvLyBJZiB0aGUgZGF0ZSBzdHJpbmcgZG9lcyBub3Qgc3BlY2lmaXkgYSB0aW1lem9uZSwgd2UgbXVzdCBzcGVjaWZpeSBVVEMuIFRoaXMgaXNcbiAgLy8gZXhwcmVzc2VkIGJ5IGVuZGluZyB3aXRoICdaJ1xuXG4gIGlmIChkYXRlUmVnZXgudGVzdChzdHIpKSB7XG4gICAgc3RyICs9ICdaJztcbiAgfVxuXG4gIHJldHVybiBEYXRlLnBhcnNlKHN0cik7XG59O1xuXG5jb25zdCBwYXJzZXJzID0ge1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgZW50aXJlIE1lZGlhIFByZXNlbnRhdGlvbi4gRm9ybWF0IGlzIGEgZHVyYXRpb24gc3RyaW5nXG4gICAqIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIG1lZGlhUHJlc2VudGF0aW9uRHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgU2VnbWVudCBhdmFpbGFiaWxpdHkgc3RhcnQgdGltZSBmb3IgYWxsIFNlZ21lbnRzIHJlZmVycmVkIHRvIGluIHRoaXNcbiAgICogTVBELiBGb3IgYSBkeW5hbWljIG1hbmlmZXN0LCBpdCBzcGVjaWZpZXMgdGhlIGFuY2hvciBmb3IgdGhlIGVhcmxpZXN0IGF2YWlsYWJpbGl0eVxuICAgKiB0aW1lLiBGb3JtYXQgaXMgYSBkYXRlIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkYXRlIGFzIHNlY29uZHMgZnJvbSB1bml4IGVwb2NoXG4gICAqL1xuICBhdmFpbGFiaWxpdHlTdGFydFRpbWUodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEYXRlKHZhbHVlKSAvIDEwMDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgc21hbGxlc3QgcGVyaW9kIGJldHdlZW4gcG90ZW50aWFsIGNoYW5nZXMgdG8gdGhlIE1QRC4gRm9ybWF0IGlzIGFcbiAgICogZHVyYXRpb24gc3RyaW5nIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIG1pbmltdW1VcGRhdGVQZXJpb2QodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgc3VnZ2VzdGVkIHByZXNlbnRhdGlvbiBkZWxheS4gRm9ybWF0IGlzIGFcbiAgICogZHVyYXRpb24gc3RyaW5nIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIHN1Z2dlc3RlZFByZXNlbnRhdGlvbkRlbGF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzcGVjaWZpY2VzIHRoZSB0eXBlIG9mIG1wZC4gQ2FuIGJlIGVpdGhlciBcInN0YXRpY1wiIG9yIFwiZHluYW1pY1wiXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgdHlwZSBhcyBhIHN0cmluZ1xuICAgKi9cbiAgdHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgc21hbGxlc3QgdGltZSBzaGlmdGluZyBidWZmZXIgZm9yIGFueSBSZXByZXNlbnRhdGlvblxuICAgKiBpbiB0aGUgTVBELiBGb3JtYXQgaXMgYSBkdXJhdGlvbiBzdHJpbmcgYXMgc3BlY2lmaWVkIGluIElTTyA4NjAxXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKi9cbiAgdGltZVNoaWZ0QnVmZmVyRGVwdGgodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgUGVyaW9kU3RhcnQgdGltZSBvZiB0aGUgUGVyaW9kIHJlbGF0aXZlIHRvIHRoZSBhdmFpbGFiaWxpdHlTdGFydHRpbWUuXG4gICAqIEZvcm1hdCBpcyBhIGR1cmF0aW9uIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqL1xuICBzdGFydCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUR1cmF0aW9uKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSB3aWR0aCBvZiB0aGUgdmlzdWFsIHByZXNlbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCB3aWR0aFxuICAgKi9cbiAgd2lkdGgodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBoZWlnaHQgb2YgdGhlIHZpc3VhbCBwcmVzZW50YXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgaGVpZ2h0XG4gICAqL1xuICBoZWlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBiaXRyYXRlIG9mIHRoZSByZXByZXNlbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBiYW5kd2lkdGhcbiAgICovXG4gIGJhbmR3aWR0aCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZyYW1lIHJhdGUgb2YgdGhlIHJlcHJlc2VudGF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIGZyYW1lIHJhdGVcbiAgICovXG4gIGZyYW1lUmF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZURpdmlzaW9uVmFsdWUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aGUgZmlyc3QgTWVkaWEgU2VnbWVudCBpbiB0aGlzIFJlcHJlc2VudGF0aW9uIGluIHRoZSBQZXJpb2RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgbnVtYmVyXG4gICAqL1xuICBzdGFydE51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHRpbWVzY2FsZSBpbiB1bml0cyBwZXIgc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCB0aW1lc2NhbGVcbiAgICovXG4gIHRpbWVzY2FsZSh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHByZXNlbnRhdGlvblRpbWVPZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBwcmVzZW50YXRpb25UaW1lT2Zmc2V0XG4gICAqL1xuICBwcmVzZW50YXRpb25UaW1lT2Zmc2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgY29uc3RhbnQgYXBwcm94aW1hdGUgU2VnbWVudCBkdXJhdGlvblxuICAgKiBOT1RFOiBUaGUgPFBlcmlvZD4gZWxlbWVudCBhbHNvIGNvbnRhaW5zIGFuIEBkdXJhdGlvbiBhdHRyaWJ1dGUuIFRoaXMgZHVyYXRpb25cbiAgICogICAgICAgc3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgUGVyaW9kLiBUaGlzIGF0dHJpYnV0ZSBpcyBjdXJyZW50bHkgbm90XG4gICAqICAgICAgIHN1cHBvcnRlZCBieSB0aGUgcmVzdCBvZiB0aGUgcGFyc2VyLCBob3dldmVyIHdlIHN0aWxsIGNoZWNrIGZvciBpdCB0byBwcmV2ZW50XG4gICAqICAgICAgIGVycm9ycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgZHVyYXRpb25cbiAgICovXG4gIGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuXG4gICAgaWYgKGlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWRWYWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBTZWdtZW50IGR1cmF0aW9uLCBpbiB1bml0cyBvZiB0aGUgdmFsdWUgb2YgdGhlIEB0aW1lc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIGR1cmF0aW9uXG4gICAqL1xuICBkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgTVBEIHN0YXJ0IHRpbWUsIGluIEB0aW1lc2NhbGUgdW5pdHMsIHRoZSBmaXJzdCBTZWdtZW50IGluIHRoZSBzZXJpZXNcbiAgICogc3RhcnRzIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBlcmlvZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCB0aW1lXG4gICAqL1xuICB0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgcmVwZWF0IGNvdW50IG9mIHRoZSBudW1iZXIgb2YgZm9sbG93aW5nIGNvbnRpZ3VvdXMgU2VnbWVudHMgd2l0aCB0aGVcbiAgICogc2FtZSBkdXJhdGlvbiBleHByZXNzZWQgYnkgdGhlIHZhbHVlIG9mIEBkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIG51bWJlclxuICAgKi9cbiAgcih2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHByZXNlbnRhdGlvblRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBwcmVzZW50YXRpb25UaW1lXG4gICAqL1xuICBwcmVzZW50YXRpb25UaW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcGFyc2VyIGZvciBhbGwgb3RoZXIgYXR0cmlidXRlcy4gQWN0cyBhcyBhIG5vLW9wIGFuZCBqdXN0IHJldHVybnMgdGhlIHZhbHVlXG4gICAqIGFzIGEgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBVbnBhcnNlZCB2YWx1ZVxuICAgKi9cbiAgREVGQVVMVCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG59O1xuLyoqXG4gKiBHZXRzIGFsbCB0aGUgYXR0cmlidXRlcyBhbmQgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBub2RlLCBwYXJzZXMgYXR0cmlidXRlcyB3aXRoIGtub3duXG4gKiB0eXBlcywgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYXR0cmlidXRlIG5hbWVzIG1hcHBlZCB0byB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogICAgICAgIFRoZSBub2RlIHRvIHBhcnNlIGF0dHJpYnV0ZXMgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBPYmplY3Qgd2l0aCBhbGwgYXR0cmlidXRlcyBvZiBlbCBwYXJzZWRcbiAqL1xuXG5jb25zdCBwYXJzZUF0dHJpYnV0ZXMgPSBlbCA9PiB7XG4gIGlmICghKGVsICYmIGVsLmF0dHJpYnV0ZXMpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmV0dXJuIGZyb20oZWwuYXR0cmlidXRlcykucmVkdWNlKChhLCBlKSA9PiB7XG4gICAgY29uc3QgcGFyc2VGbiA9IHBhcnNlcnNbZS5uYW1lXSB8fCBwYXJzZXJzLkRFRkFVTFQ7XG4gICAgYVtlLm5hbWVdID0gcGFyc2VGbihlLnZhbHVlKTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufTtcblxuY29uc3Qga2V5U3lzdGVtc01hcCA9IHtcbiAgJ3Vybjp1dWlkOjEwNzdlZmVjLWMwYjItNGQwMi1hY2UzLTNjMWU1MmUyZmI0Yic6ICdvcmcudzMuY2xlYXJrZXknLFxuICAndXJuOnV1aWQ6ZWRlZjhiYTktNzlkNi00YWNlLWEzYzgtMjdkY2Q1MWQyMWVkJzogJ2NvbS53aWRldmluZS5hbHBoYScsXG4gICd1cm46dXVpZDo5YTA0ZjA3OS05ODQwLTQyODYtYWI5Mi1lNjViZTA4ODVmOTUnOiAnY29tLm1pY3Jvc29mdC5wbGF5cmVhZHknLFxuICAndXJuOnV1aWQ6ZjIzOWU3NjktZWZhMy00ODUwLTljMTYtYTkwM2M2OTMyZWZiJzogJ2NvbS5hZG9iZS5wcmltZXRpbWUnLFxuICAvLyBJU09fSUVDIDIzMDA5LTFfMjAyMiA1LjguNS4yLjIgVGhlIG1wNCBQcm90ZWN0aW9uIFNjaGVtZVxuICAndXJuOm1wZWc6ZGFzaDptcDRwcm90ZWN0aW9uOjIwMTEnOiAnbXA0cHJvdGVjdGlvbidcbn07XG4vKipcbiAqIEJ1aWxkcyBhIGxpc3Qgb2YgdXJscyB0aGF0IGlzIHRoZSBwcm9kdWN0IG9mIHRoZSByZWZlcmVuY2UgdXJscyBhbmQgQmFzZVVSTCB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSByZWZlcmVuY2VzXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHJlZmVyZW5jZSBVUkwgYXMgd2VsbCBhcyBpdHMgYXR0cmlidXRlc1xuICogQHBhcmFtIHtOb2RlW119IGJhc2VVcmxFbGVtZW50c1xuICogICAgICAgIExpc3Qgb2YgQmFzZVVSTCBub2RlcyBmcm9tIHRoZSBtcGRcbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICogICAgICAgICBMaXN0IG9mIG9iamVjdHMgd2l0aCByZXNvbHZlZCB1cmxzIGFuZCBhdHRyaWJ1dGVzXG4gKi9cblxuY29uc3QgYnVpbGRCYXNlVXJscyA9IChyZWZlcmVuY2VzLCBiYXNlVXJsRWxlbWVudHMpID0+IHtcbiAgaWYgKCFiYXNlVXJsRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gIH1cblxuICByZXR1cm4gZmxhdHRlbihyZWZlcmVuY2VzLm1hcChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIGJhc2VVcmxFbGVtZW50cy5tYXAoZnVuY3Rpb24gKGJhc2VVcmxFbGVtZW50KSB7XG4gICAgICBjb25zdCBpbml0aWFsQmFzZVVybCA9IGdldENvbnRlbnQoYmFzZVVybEVsZW1lbnQpO1xuICAgICAgY29uc3QgcmVzb2x2ZWRCYXNlVXJsID0gcmVzb2x2ZVVybChyZWZlcmVuY2UuYmFzZVVybCwgaW5pdGlhbEJhc2VVcmwpO1xuICAgICAgY29uc3QgZmluYWxCYXNlVXJsID0gbWVyZ2UocGFyc2VBdHRyaWJ1dGVzKGJhc2VVcmxFbGVtZW50KSwge1xuICAgICAgICBiYXNlVXJsOiByZXNvbHZlZEJhc2VVcmxcbiAgICAgIH0pOyAvLyBJZiB0aGUgVVJMIGlzIHJlc29sdmVkLCB3ZSB3YW50IHRvIGdldCB0aGUgc2VydmljZUxvY2F0aW9uIGZyb20gdGhlIHJlZmVyZW5jZVxuICAgICAgLy8gYXNzdW1pbmcgdGhlcmUgaXMgbm8gc2VydmljZUxvY2F0aW9uIG9uIHRoZSBpbml0aWFsQmFzZVVybFxuXG4gICAgICBpZiAocmVzb2x2ZWRCYXNlVXJsICE9PSBpbml0aWFsQmFzZVVybCAmJiAhZmluYWxCYXNlVXJsLnNlcnZpY2VMb2NhdGlvbiAmJiByZWZlcmVuY2Uuc2VydmljZUxvY2F0aW9uKSB7XG4gICAgICAgIGZpbmFsQmFzZVVybC5zZXJ2aWNlTG9jYXRpb24gPSByZWZlcmVuY2Uuc2VydmljZUxvY2F0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmluYWxCYXNlVXJsO1xuICAgIH0pO1xuICB9KSk7XG59O1xuLyoqXG4gKiBDb250YWlucyBhbGwgU2VnbWVudCBpbmZvcm1hdGlvbiBmb3IgaXRzIGNvbnRhaW5pbmcgQWRhcHRhdGlvblNldFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnRJbmZvcm1hdGlvblxuICogQHByb3BlcnR5IHtPYmplY3R8dW5kZWZpbmVkfSB0ZW1wbGF0ZVxuICogICAgICAgICAgIENvbnRhaW5zIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgU2VnbWVudFRlbXBsYXRlIG5vZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0W118dW5kZWZpbmVkfSBzZWdtZW50VGltZWxpbmVcbiAqICAgICAgICAgICBDb250YWlucyBhIGxpc3Qgb2YgYXRycmlidXRlcyBmb3IgZWFjaCBTIG5vZGUgd2l0aGluIHRoZSBTZWdtZW50VGltZWxpbmUgbm9kZVxuICogQHByb3BlcnR5IHtPYmplY3R8dW5kZWZpbmVkfSBsaXN0XG4gKiAgICAgICAgICAgQ29udGFpbnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBTZWdtZW50TGlzdCBub2RlXG4gKiBAcHJvcGVydHkge09iamVjdHx1bmRlZmluZWR9IGJhc2VcbiAqICAgICAgICAgICBDb250YWlucyB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIFNlZ21lbnRCYXNlIG5vZGVcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBTZWdtZW50IGluZm9ybWF0aW9uIGNvbnRhaW5lZCB3aXRoaW4gdGhlIEFkYXB0YXRpb25TZXQgbm9kZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gYWRhcHRhdGlvblNldFxuICogICAgICAgIFRoZSBBZGFwdGF0aW9uU2V0IG5vZGUgdG8gZ2V0IFNlZ21lbnQgaW5mb3JtYXRpb24gZnJvbVxuICogQHJldHVybiB7U2VnbWVudEluZm9ybWF0aW9ufVxuICogICAgICAgICBUaGUgU2VnbWVudCBpbmZvcm1hdGlvbiBjb250YWluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBBZGFwdGF0aW9uU2V0XG4gKi9cblxuY29uc3QgZ2V0U2VnbWVudEluZm9ybWF0aW9uID0gYWRhcHRhdGlvblNldCA9PiB7XG4gIGNvbnN0IHNlZ21lbnRUZW1wbGF0ZSA9IGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnU2VnbWVudFRlbXBsYXRlJylbMF07XG4gIGNvbnN0IHNlZ21lbnRMaXN0ID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdTZWdtZW50TGlzdCcpWzBdO1xuICBjb25zdCBzZWdtZW50VXJscyA9IHNlZ21lbnRMaXN0ICYmIGZpbmRDaGlsZHJlbihzZWdtZW50TGlzdCwgJ1NlZ21lbnRVUkwnKS5tYXAocyA9PiBtZXJnZSh7XG4gICAgdGFnOiAnU2VnbWVudFVSTCdcbiAgfSwgcGFyc2VBdHRyaWJ1dGVzKHMpKSk7XG4gIGNvbnN0IHNlZ21lbnRCYXNlID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdTZWdtZW50QmFzZScpWzBdO1xuICBjb25zdCBzZWdtZW50VGltZWxpbmVQYXJlbnROb2RlID0gc2VnbWVudExpc3QgfHwgc2VnbWVudFRlbXBsYXRlO1xuICBjb25zdCBzZWdtZW50VGltZWxpbmUgPSBzZWdtZW50VGltZWxpbmVQYXJlbnROb2RlICYmIGZpbmRDaGlsZHJlbihzZWdtZW50VGltZWxpbmVQYXJlbnROb2RlLCAnU2VnbWVudFRpbWVsaW5lJylbMF07XG4gIGNvbnN0IHNlZ21lbnRJbml0aWFsaXphdGlvblBhcmVudE5vZGUgPSBzZWdtZW50TGlzdCB8fCBzZWdtZW50QmFzZSB8fCBzZWdtZW50VGVtcGxhdGU7XG4gIGNvbnN0IHNlZ21lbnRJbml0aWFsaXphdGlvbiA9IHNlZ21lbnRJbml0aWFsaXphdGlvblBhcmVudE5vZGUgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRJbml0aWFsaXphdGlvblBhcmVudE5vZGUsICdJbml0aWFsaXphdGlvbicpWzBdOyAvLyBTZWdtZW50VGVtcGxhdGUgaXMgaGFuZGxlZCBzbGlnaHRseSBkaWZmZXJlbnRseSwgc2luY2UgaXQgY2FuIGhhdmUgYm90aFxuICAvLyBAaW5pdGlhbGl6YXRpb24gYW5kIGFuIDxJbml0aWFsaXphdGlvbj4gbm9kZS4gIEBpbml0aWFsaXphdGlvbiBjYW4gYmUgdGVtcGxhdGVkLFxuICAvLyB3aGlsZSB0aGUgbm9kZSBjYW4gaGF2ZSBhIHVybCBhbmQgcmFuZ2Ugc3BlY2lmaWVkLiAgSWYgdGhlIDxTZWdtZW50VGVtcGxhdGU+IGhhc1xuICAvLyBib3RoIEBpbml0aWFsaXphdGlvbiBhbmQgYW4gPEluaXRpYWxpemF0aW9uPiBzdWJlbGVtZW50IHdlIG9wdCB0byBvdmVycmlkZSB3aXRoXG4gIC8vIHRoZSBub2RlLCBhcyB0aGlzIGludGVyYWN0aW9uIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBzcGVjLlxuXG4gIGNvbnN0IHRlbXBsYXRlID0gc2VnbWVudFRlbXBsYXRlICYmIHBhcnNlQXR0cmlidXRlcyhzZWdtZW50VGVtcGxhdGUpO1xuXG4gIGlmICh0ZW1wbGF0ZSAmJiBzZWdtZW50SW5pdGlhbGl6YXRpb24pIHtcbiAgICB0ZW1wbGF0ZS5pbml0aWFsaXphdGlvbiA9IHNlZ21lbnRJbml0aWFsaXphdGlvbiAmJiBwYXJzZUF0dHJpYnV0ZXMoc2VnbWVudEluaXRpYWxpemF0aW9uKTtcbiAgfSBlbHNlIGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5pbml0aWFsaXphdGlvbikge1xuICAgIC8vIElmIGl0IGlzIEBpbml0aWFsaXphdGlvbiB3ZSBjb252ZXJ0IGl0IHRvIGFuIG9iamVjdCBzaW5jZSB0aGlzIGlzIHRoZSBmb3JtYXQgdGhhdFxuICAgIC8vIGxhdGVyIGZ1bmN0aW9ucyB3aWxsIHJlbHkgb24gZm9yIHRoZSBpbml0aWFsaXphdGlvbiBzZWdtZW50LiAgVGhpcyBpcyBvbmx5IHZhbGlkXG4gICAgLy8gZm9yIDxTZWdtZW50VGVtcGxhdGU+XG4gICAgdGVtcGxhdGUuaW5pdGlhbGl6YXRpb24gPSB7XG4gICAgICBzb3VyY2VVUkw6IHRlbXBsYXRlLmluaXRpYWxpemF0aW9uXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHNlZ21lbnRJbmZvID0ge1xuICAgIHRlbXBsYXRlLFxuICAgIHNlZ21lbnRUaW1lbGluZTogc2VnbWVudFRpbWVsaW5lICYmIGZpbmRDaGlsZHJlbihzZWdtZW50VGltZWxpbmUsICdTJykubWFwKHMgPT4gcGFyc2VBdHRyaWJ1dGVzKHMpKSxcbiAgICBsaXN0OiBzZWdtZW50TGlzdCAmJiBtZXJnZShwYXJzZUF0dHJpYnV0ZXMoc2VnbWVudExpc3QpLCB7XG4gICAgICBzZWdtZW50VXJscyxcbiAgICAgIGluaXRpYWxpemF0aW9uOiBwYXJzZUF0dHJpYnV0ZXMoc2VnbWVudEluaXRpYWxpemF0aW9uKVxuICAgIH0pLFxuICAgIGJhc2U6IHNlZ21lbnRCYXNlICYmIG1lcmdlKHBhcnNlQXR0cmlidXRlcyhzZWdtZW50QmFzZSksIHtcbiAgICAgIGluaXRpYWxpemF0aW9uOiBwYXJzZUF0dHJpYnV0ZXMoc2VnbWVudEluaXRpYWxpemF0aW9uKVxuICAgIH0pXG4gIH07XG4gIE9iamVjdC5rZXlzKHNlZ21lbnRJbmZvKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKCFzZWdtZW50SW5mb1trZXldKSB7XG4gICAgICBkZWxldGUgc2VnbWVudEluZm9ba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VnbWVudEluZm87XG59O1xuLyoqXG4gKiBDb250YWlucyBTZWdtZW50IGluZm9ybWF0aW9uIGFuZCBhdHRyaWJ1dGVzIG5lZWRlZCB0byBjb25zdHJ1Y3QgYSBQbGF5bGlzdCBvYmplY3RcbiAqIGZyb20gYSBSZXByZXNlbnRhdGlvblxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlcHJlc2VudGF0aW9uSW5mb3JtYXRpb25cbiAqIEBwcm9wZXJ0eSB7U2VnbWVudEluZm9ybWF0aW9ufSBzZWdtZW50SW5mb1xuICogICAgICAgICAgIFNlZ21lbnQgaW5mb3JtYXRpb24gZm9yIHRoaXMgUmVwcmVzZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgICAgSW5oZXJpdGVkIGF0dHJpYnV0ZXMgZm9yIHRoaXMgUmVwcmVzZW50YXRpb25cbiAqL1xuXG4vKipcbiAqIE1hcHMgYSBSZXByZXNlbnRhdGlvbiBub2RlIHRvIGFuIG9iamVjdCBjb250YWluaW5nIFNlZ21lbnQgaW5mb3JtYXRpb24gYW5kIGF0dHJpYnV0ZXNcbiAqXG4gKiBAbmFtZSBpbmhlcml0QmFzZVVybHNDYWxsYmFja1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge05vZGV9IHJlcHJlc2VudGF0aW9uXG4gKiAgICAgICAgUmVwcmVzZW50YXRpb24gbm9kZSBmcm9tIHRoZSBtcGRcbiAqIEByZXR1cm4ge1JlcHJlc2VudGF0aW9uSW5mb3JtYXRpb259XG4gKiAgICAgICAgIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uIG5lZWRlZCB0byBjb25zdHJ1Y3QgYSBQbGF5bGlzdCBvYmplY3RcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBjYWxsYmFjayBmb3IgQXJyYXkucHJvdG90eXBlLm1hcCBmb3IgbWFwcGluZyBSZXByZXNlbnRhdGlvbiBub2RlcyB0b1xuICogU2VnbWVudCBpbmZvcm1hdGlvbiBhbmQgYXR0cmlidXRlcyB1c2luZyBpbmhlcml0ZWQgQmFzZVVSTCBub2Rlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYWRhcHRhdGlvblNldEF0dHJpYnV0ZXNcbiAqICAgICAgICBDb250YWlucyBhdHRyaWJ1dGVzIGluaGVyaXRlZCBieSB0aGUgQWRhcHRhdGlvblNldFxuICogQHBhcmFtIHtPYmplY3RbXX0gYWRhcHRhdGlvblNldEJhc2VVcmxzXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgcmVzb2x2ZWQgYmFzZSBVUkxzIGFuZCBhdHRyaWJ1dGVzXG4gKiAgICAgICAgaW5oZXJpdGVkIGJ5IHRoZSBBZGFwdGF0aW9uU2V0XG4gKiBAcGFyYW0ge1NlZ21lbnRJbmZvcm1hdGlvbn0gYWRhcHRhdGlvblNldFNlZ21lbnRJbmZvXG4gKiAgICAgICAgQ29udGFpbnMgU2VnbWVudCBpbmZvcm1hdGlvbiBmb3IgdGhlIEFkYXB0YXRpb25TZXRcbiAqIEByZXR1cm4ge2luaGVyaXRCYXNlVXJsc0NhbGxiYWNrfVxuICogICAgICAgICBDYWxsYmFjayBtYXAgZnVuY3Rpb25cbiAqL1xuXG5jb25zdCBpbmhlcml0QmFzZVVybHMgPSAoYWRhcHRhdGlvblNldEF0dHJpYnV0ZXMsIGFkYXB0YXRpb25TZXRCYXNlVXJscywgYWRhcHRhdGlvblNldFNlZ21lbnRJbmZvKSA9PiByZXByZXNlbnRhdGlvbiA9PiB7XG4gIGNvbnN0IHJlcEJhc2VVcmxFbGVtZW50cyA9IGZpbmRDaGlsZHJlbihyZXByZXNlbnRhdGlvbiwgJ0Jhc2VVUkwnKTtcbiAgY29uc3QgcmVwQmFzZVVybHMgPSBidWlsZEJhc2VVcmxzKGFkYXB0YXRpb25TZXRCYXNlVXJscywgcmVwQmFzZVVybEVsZW1lbnRzKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IG1lcmdlKGFkYXB0YXRpb25TZXRBdHRyaWJ1dGVzLCBwYXJzZUF0dHJpYnV0ZXMocmVwcmVzZW50YXRpb24pKTtcbiAgY29uc3QgcmVwcmVzZW50YXRpb25TZWdtZW50SW5mbyA9IGdldFNlZ21lbnRJbmZvcm1hdGlvbihyZXByZXNlbnRhdGlvbik7XG4gIHJldHVybiByZXBCYXNlVXJscy5tYXAoYmFzZVVybCA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlZ21lbnRJbmZvOiBtZXJnZShhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8sIHJlcHJlc2VudGF0aW9uU2VnbWVudEluZm8pLFxuICAgICAgYXR0cmlidXRlczogbWVyZ2UoYXR0cmlidXRlcywgYmFzZVVybClcbiAgICB9O1xuICB9KTtcbn07XG4vKipcbiAqIFRyYW5mb3JtcyBhIHNlcmllcyBvZiBjb250ZW50IHByb3RlY3Rpb24gbm9kZXMgdG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHBzc2ggZGF0YSBieSBrZXkgc3lzdGVtXG4gKlxuICogQHBhcmFtIHtOb2RlW119IGNvbnRlbnRQcm90ZWN0aW9uTm9kZXNcbiAqICAgICAgICBDb250ZW50IHByb3RlY3Rpb24gbm9kZXNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBwc3NoIGRhdGEgYnkga2V5IHN5c3RlbVxuICovXG5cbmNvbnN0IGdlbmVyYXRlS2V5U3lzdGVtSW5mb3JtYXRpb24gPSBjb250ZW50UHJvdGVjdGlvbk5vZGVzID0+IHtcbiAgcmV0dXJuIGNvbnRlbnRQcm90ZWN0aW9uTm9kZXMucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG5vZGUpOyAvLyBBbHRob3VnaCBpdCBjb3VsZCBiZSBhcmd1ZWQgdGhhdCBhY2NvcmRpbmcgdG8gdGhlIFVVSUQgUkZDIHNwZWMgdGhlIFVVSUQgc3RyaW5nIChhLWYgY2hhcnMpIHNob3VsZCBiZSBnZW5lcmF0ZWRcbiAgICAvLyBhcyBhIGxvd2VyY2FzZSBzdHJpbmcgaXQgYWxzbyBtZW50aW9ucyBpdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBjYXNlLWluc2Vuc2l0aXZlIG9uIGlucHV0LiBTaW5jZSB0aGUga2V5IHN5c3RlbVxuICAgIC8vIFVVSURzIGluIHRoZSBrZXlTeXN0ZW1zTWFwIGFyZSBoYXJkY29kZWQgYXMgbG93ZXJjYXNlIGluIHRoZSBjb2RlYmFzZSB0aGVyZSBpc24ndCBhbnkgcmVhc29uIG5vdCB0byBkb1xuICAgIC8vIC50b0xvd2VyQ2FzZSgpIG9uIHRoZSBpbnB1dCBVVUlEIHN0cmluZyBmcm9tIHRoZSBtYW5pZmVzdCAoYXQgbGVhc3QgSSBjb3VsZCBub3QgdGhpbmsgb2Ygb25lKS5cblxuICAgIGlmIChhdHRyaWJ1dGVzLnNjaGVtZUlkVXJpKSB7XG4gICAgICBhdHRyaWJ1dGVzLnNjaGVtZUlkVXJpID0gYXR0cmlidXRlcy5zY2hlbWVJZFVyaS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGtleVN5c3RlbSA9IGtleVN5c3RlbXNNYXBbYXR0cmlidXRlcy5zY2hlbWVJZFVyaV07XG5cbiAgICBpZiAoa2V5U3lzdGVtKSB7XG4gICAgICBhY2Nba2V5U3lzdGVtXSA9IHtcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHBzc2hOb2RlID0gZmluZENoaWxkcmVuKG5vZGUsICdjZW5jOnBzc2gnKVswXTtcblxuICAgICAgaWYgKHBzc2hOb2RlKSB7XG4gICAgICAgIGNvbnN0IHBzc2ggPSBnZXRDb250ZW50KHBzc2hOb2RlKTtcbiAgICAgICAgYWNjW2tleVN5c3RlbV0ucHNzaCA9IHBzc2ggJiYgZGVjb2RlQjY0VG9VaW50OEFycmF5KHBzc2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07IC8vIGRlZmluZWQgaW4gQU5TSV9TQ1RFIDIxNC0xIDIwMTZcblxuXG5jb25zdCBwYXJzZUNhcHRpb25TZXJ2aWNlTWV0YWRhdGEgPSBzZXJ2aWNlID0+IHtcbiAgLy8gNjA4IGNhcHRpb25zXG4gIGlmIChzZXJ2aWNlLnNjaGVtZUlkVXJpID09PSAndXJuOnNjdGU6ZGFzaDpjYzpjZWEtNjA4OjIwMTUnKSB7XG4gICAgY29uc3QgdmFsdWVzID0gdHlwZW9mIHNlcnZpY2UudmFsdWUgIT09ICdzdHJpbmcnID8gW10gOiBzZXJ2aWNlLnZhbHVlLnNwbGl0KCc7Jyk7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAodmFsdWUgPT4ge1xuICAgICAgbGV0IGNoYW5uZWw7XG4gICAgICBsZXQgbGFuZ3VhZ2U7IC8vIGRlZmF1bHQgbGFuZ3VhZ2UgdG8gdmFsdWVcblxuICAgICAgbGFuZ3VhZ2UgPSB2YWx1ZTtcblxuICAgICAgaWYgKC9eQ0NcXGQ9Ly50ZXN0KHZhbHVlKSkge1xuICAgICAgICBbY2hhbm5lbCwgbGFuZ3VhZ2VdID0gdmFsdWUuc3BsaXQoJz0nKTtcbiAgICAgIH0gZWxzZSBpZiAoL15DQ1xcZCQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGNoYW5uZWwgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgbGFuZ3VhZ2VcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2VydmljZS5zY2hlbWVJZFVyaSA9PT0gJ3VybjpzY3RlOmRhc2g6Y2M6Y2VhLTcwODoyMDE1Jykge1xuICAgIGNvbnN0IHZhbHVlcyA9IHR5cGVvZiBzZXJ2aWNlLnZhbHVlICE9PSAnc3RyaW5nJyA/IFtdIDogc2VydmljZS52YWx1ZS5zcGxpdCgnOycpO1xuICAgIHJldHVybiB2YWx1ZXMubWFwKHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IGZsYWdzID0ge1xuICAgICAgICAvLyBzZXJ2aWNlIG9yIGNoYW5uZWwgbnVtYmVyIDEtNjNcbiAgICAgICAgJ2NoYW5uZWwnOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIGxhbmd1YWdlIGlzIGEgM0FMUEhBIHBlciBJU08gNjM5LjIvQlxuICAgICAgICAvLyBmaWVsZCBpcyByZXF1aXJlZFxuICAgICAgICAnbGFuZ3VhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIEJJVCAxLzAgb3IgP1xuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlIGlzIDEsIG1lYW5pbmcgMTY6OSBhc3BlY3QgcmF0aW8sIDAgaXMgNDozLCA/IGlzIHVua25vd25cbiAgICAgICAgJ2FzcGVjdFJhdGlvJzogMSxcbiAgICAgICAgLy8gQklUIDEvMFxuICAgICAgICAvLyBlYXN5IHJlYWRlciBmbGFnIGluZGljYXRlZCB0aGUgdGV4dCBpcyB0YWlsZWQgdG8gdGhlIG5lZWRzIG9mIGJlZ2lubmluZyByZWFkZXJzXG4gICAgICAgIC8vIGRlZmF1bHQgMCwgb3Igb2ZmXG4gICAgICAgICdlYXN5UmVhZGVyJzogMCxcbiAgICAgICAgLy8gQklUIDEvMFxuICAgICAgICAvLyBJZiAzZCBtZXRhZGF0YSBpcyBwcmVzZW50IChDRUEtNzA4LjEpIHRoZW4gMVxuICAgICAgICAvLyBkZWZhdWx0IDBcbiAgICAgICAgJzNEJzogMFxuICAgICAgfTtcblxuICAgICAgaWYgKC89Ly50ZXN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBbY2hhbm5lbCwgb3B0cyA9ICcnXSA9IHZhbHVlLnNwbGl0KCc9Jyk7XG4gICAgICAgIGZsYWdzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICBmbGFncy5sYW5ndWFnZSA9IHZhbHVlO1xuICAgICAgICBvcHRzLnNwbGl0KCcsJykuZm9yRWFjaChvcHQgPT4ge1xuICAgICAgICAgIGNvbnN0IFtuYW1lLCB2YWxdID0gb3B0LnNwbGl0KCc6Jyk7XG5cbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xhbmcnKSB7XG4gICAgICAgICAgICBmbGFncy5sYW5ndWFnZSA9IHZhbDsgLy8gZXIgZm9yIGVhc3lSZWFkZXJ5XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnZXInKSB7XG4gICAgICAgICAgICBmbGFncy5lYXN5UmVhZGVyID0gTnVtYmVyKHZhbCk7IC8vIHdhciBmb3Igd2lkZSBhc3BlY3QgcmF0aW9cbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd3YXInKSB7XG4gICAgICAgICAgICBmbGFncy5hc3BlY3RSYXRpbyA9IE51bWJlcih2YWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJzNEJykge1xuICAgICAgICAgICAgZmxhZ3NbJzNEJ10gPSBOdW1iZXIodmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhZ3MubGFuZ3VhZ2UgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsYWdzLmNoYW5uZWwpIHtcbiAgICAgICAgZmxhZ3MuY2hhbm5lbCA9ICdTRVJWSUNFJyArIGZsYWdzLmNoYW5uZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbGFncztcbiAgICB9KTtcbiAgfVxufTtcbi8qKlxuICogQSBtYXAgY2FsbGJhY2sgdGhhdCB3aWxsIHBhcnNlIGFsbCBldmVudCBzdHJlYW0gZGF0YSBmb3IgYSBjb2xsZWN0aW9uIG9mIHBlcmlvZHNcbiAqIERBU0ggSVNPX0lFQ18yMzAwOSA1LjEwLjIuMlxuICogaHR0cHM6Ly9kYXNoaWYtZG9jdW1lbnRzLmF6dXJld2Vic2l0ZXMubmV0L0V2ZW50cy9tYXN0ZXIvZXZlbnQuaHRtbCNtcGQtZXZlbnQtdGltaW5nXG4gKlxuICogQHBhcmFtIHtQZXJpb2RJbmZvcm1hdGlvbn0gcGVyaW9kIG9iamVjdCBjb250YWluaW5nIG5lY2Vzc2FyeSBwZXJpb2QgaW5mb3JtYXRpb25cbiAqIEByZXR1cm4gYSBjb2xsZWN0aW9uIG9mIHBhcnNlZCBldmVudHN0cmVhbSBldmVudCBvYmplY3RzXG4gKi9cblxuY29uc3QgdG9FdmVudFN0cmVhbSA9IHBlcmlvZCA9PiB7XG4gIC8vIGdldCBhbmQgZmxhdHRlbiBhbGwgRXZlbnRTdHJlYW1zIHRhZ3MgYW5kIHBhcnNlIGF0dHJpYnV0ZXMgYW5kIGNoaWxkcmVuXG4gIHJldHVybiBmbGF0dGVuKGZpbmRDaGlsZHJlbihwZXJpb2Qubm9kZSwgJ0V2ZW50U3RyZWFtJykubWFwKGV2ZW50U3RyZWFtID0+IHtcbiAgICBjb25zdCBldmVudFN0cmVhbUF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMoZXZlbnRTdHJlYW0pO1xuICAgIGNvbnN0IHNjaGVtZUlkVXJpID0gZXZlbnRTdHJlYW1BdHRyaWJ1dGVzLnNjaGVtZUlkVXJpOyAvLyBmaW5kIGFsbCBFdmVudHMgcGVyIEV2ZW50U3RyZWFtIHRhZyBhbmQgbWFwIHRvIHJldHVybiBvYmplY3RzXG5cbiAgICByZXR1cm4gZmluZENoaWxkcmVuKGV2ZW50U3RyZWFtLCAnRXZlbnQnKS5tYXAoZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZXZlbnRBdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKGV2ZW50KTtcbiAgICAgIGNvbnN0IHByZXNlbnRhdGlvblRpbWUgPSBldmVudEF0dHJpYnV0ZXMucHJlc2VudGF0aW9uVGltZSB8fCAwO1xuICAgICAgY29uc3QgdGltZXNjYWxlID0gZXZlbnRTdHJlYW1BdHRyaWJ1dGVzLnRpbWVzY2FsZSB8fCAxO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBldmVudEF0dHJpYnV0ZXMuZHVyYXRpb24gfHwgMDtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcHJlc2VudGF0aW9uVGltZSAvIHRpbWVzY2FsZSArIHBlcmlvZC5hdHRyaWJ1dGVzLnN0YXJ0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lSWRVcmksXG4gICAgICAgIHZhbHVlOiBldmVudFN0cmVhbUF0dHJpYnV0ZXMudmFsdWUsXG4gICAgICAgIGlkOiBldmVudEF0dHJpYnV0ZXMuaWQsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQ6IHN0YXJ0ICsgZHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgIG1lc3NhZ2VEYXRhOiBnZXRDb250ZW50KGV2ZW50KSB8fCBldmVudEF0dHJpYnV0ZXMubWVzc2FnZURhdGEsXG4gICAgICAgIGNvbnRlbnRFbmNvZGluZzogZXZlbnRTdHJlYW1BdHRyaWJ1dGVzLmNvbnRlbnRFbmNvZGluZyxcbiAgICAgICAgcHJlc2VudGF0aW9uVGltZU9mZnNldDogZXZlbnRTdHJlYW1BdHRyaWJ1dGVzLnByZXNlbnRhdGlvblRpbWVPZmZzZXQgfHwgMFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSkpO1xufTtcbi8qKlxuICogTWFwcyBhbiBBZGFwdGF0aW9uU2V0IG5vZGUgdG8gYSBsaXN0IG9mIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uIG9iamVjdHNcbiAqXG4gKiBAbmFtZSB0b1JlcHJlc2VudGF0aW9uc0NhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Tm9kZX0gYWRhcHRhdGlvblNldFxuICogICAgICAgIEFkYXB0YXRpb25TZXQgbm9kZSBmcm9tIHRoZSBtcGRcbiAqIEByZXR1cm4ge1JlcHJlc2VudGF0aW9uSW5mb3JtYXRpb25bXX1cbiAqICAgICAgICAgTGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgUmVwcmVzZW50YWlvbiBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGNhbGxiYWNrIGZvciBBcnJheS5wcm90b3R5cGUubWFwIGZvciBtYXBwaW5nIEFkYXB0YXRpb25TZXQgbm9kZXMgdG8gYSBsaXN0IG9mXG4gKiBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBvYmplY3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBlcmlvZEF0dHJpYnV0ZXNcbiAqICAgICAgICBDb250YWlucyBhdHRyaWJ1dGVzIGluaGVyaXRlZCBieSB0aGUgUGVyaW9kXG4gKiBAcGFyYW0ge09iamVjdFtdfSBwZXJpb2RCYXNlVXJsc1xuICogICAgICAgIENvbnRhaW5zIGxpc3Qgb2Ygb2JqZWN0cyB3aXRoIHJlc29sdmVkIGJhc2UgdXJscyBhbmQgYXR0cmlidXRlc1xuICogICAgICAgIGluaGVyaXRlZCBieSB0aGUgUGVyaW9kXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJpb2RTZWdtZW50SW5mb1xuICogICAgICAgIENvbnRhaW5zIFNlZ21lbnQgSW5mb3JtYXRpb24gYXQgdGhlIHBlcmlvZCBsZXZlbFxuICogQHJldHVybiB7dG9SZXByZXNlbnRhdGlvbnNDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgbWFwIGZ1bmN0aW9uXG4gKi9cblxuY29uc3QgdG9SZXByZXNlbnRhdGlvbnMgPSAocGVyaW9kQXR0cmlidXRlcywgcGVyaW9kQmFzZVVybHMsIHBlcmlvZFNlZ21lbnRJbmZvKSA9PiBhZGFwdGF0aW9uU2V0ID0+IHtcbiAgY29uc3QgYWRhcHRhdGlvblNldEF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMoYWRhcHRhdGlvblNldCk7XG4gIGNvbnN0IGFkYXB0YXRpb25TZXRCYXNlVXJscyA9IGJ1aWxkQmFzZVVybHMocGVyaW9kQmFzZVVybHMsIGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnQmFzZVVSTCcpKTtcbiAgY29uc3Qgcm9sZSA9IGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnUm9sZScpWzBdO1xuICBjb25zdCByb2xlQXR0cmlidXRlcyA9IHtcbiAgICByb2xlOiBwYXJzZUF0dHJpYnV0ZXMocm9sZSlcbiAgfTtcbiAgbGV0IGF0dHJzID0gbWVyZ2UocGVyaW9kQXR0cmlidXRlcywgYWRhcHRhdGlvblNldEF0dHJpYnV0ZXMsIHJvbGVBdHRyaWJ1dGVzKTtcbiAgY29uc3QgYWNjZXNzaWJpbGl0eSA9IGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnQWNjZXNzaWJpbGl0eScpWzBdO1xuICBjb25zdCBjYXB0aW9uU2VydmljZXMgPSBwYXJzZUNhcHRpb25TZXJ2aWNlTWV0YWRhdGEocGFyc2VBdHRyaWJ1dGVzKGFjY2Vzc2liaWxpdHkpKTtcblxuICBpZiAoY2FwdGlvblNlcnZpY2VzKSB7XG4gICAgYXR0cnMgPSBtZXJnZShhdHRycywge1xuICAgICAgY2FwdGlvblNlcnZpY2VzXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBsYWJlbCA9IGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnTGFiZWwnKVswXTtcblxuICBpZiAobGFiZWwgJiYgbGFiZWwuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBsYWJlbFZhbCA9IGxhYmVsLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlLnRyaW0oKTtcbiAgICBhdHRycyA9IG1lcmdlKGF0dHJzLCB7XG4gICAgICBsYWJlbDogbGFiZWxWYWxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGNvbnRlbnRQcm90ZWN0aW9uID0gZ2VuZXJhdGVLZXlTeXN0ZW1JbmZvcm1hdGlvbihmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ0NvbnRlbnRQcm90ZWN0aW9uJykpO1xuXG4gIGlmIChPYmplY3Qua2V5cyhjb250ZW50UHJvdGVjdGlvbikubGVuZ3RoKSB7XG4gICAgYXR0cnMgPSBtZXJnZShhdHRycywge1xuICAgICAgY29udGVudFByb3RlY3Rpb25cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNlZ21lbnRJbmZvID0gZ2V0U2VnbWVudEluZm9ybWF0aW9uKGFkYXB0YXRpb25TZXQpO1xuICBjb25zdCByZXByZXNlbnRhdGlvbnMgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ1JlcHJlc2VudGF0aW9uJyk7XG4gIGNvbnN0IGFkYXB0YXRpb25TZXRTZWdtZW50SW5mbyA9IG1lcmdlKHBlcmlvZFNlZ21lbnRJbmZvLCBzZWdtZW50SW5mbyk7XG4gIHJldHVybiBmbGF0dGVuKHJlcHJlc2VudGF0aW9ucy5tYXAoaW5oZXJpdEJhc2VVcmxzKGF0dHJzLCBhZGFwdGF0aW9uU2V0QmFzZVVybHMsIGFkYXB0YXRpb25TZXRTZWdtZW50SW5mbykpKTtcbn07XG4vKipcbiAqIENvbnRhaW5zIGFsbCBwZXJpb2QgaW5mb3JtYXRpb24gZm9yIG1hcHBpbmcgbm9kZXMgb250byBhZGFwdGF0aW9uIHNldHMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUGVyaW9kSW5mb3JtYXRpb25cbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gcGVyaW9kLm5vZGVcbiAqICAgICAgICAgICBQZXJpb2Qgbm9kZSBmcm9tIHRoZSBtcGRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwZXJpb2QuYXR0cmlidXRlc1xuICogICAgICAgICAgIFBhcnNlZCBwZXJpb2QgYXR0cmlidXRlcyBmcm9tIG5vZGUgcGx1cyBhbnkgYWRkZWRcbiAqL1xuXG4vKipcbiAqIE1hcHMgYSBQZXJpb2RJbmZvcm1hdGlvbiBvYmplY3QgdG8gYSBsaXN0IG9mIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uIG9iamVjdHMgZm9yIGFsbFxuICogQWRhcHRhdGlvblNldCBub2RlcyBjb250YWluZWQgd2l0aGluIHRoZSBQZXJpb2QuXG4gKlxuICogQG5hbWUgdG9BZGFwdGF0aW9uU2V0c0NhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7UGVyaW9kSW5mb3JtYXRpb259IHBlcmlvZFxuICogICAgICAgIFBlcmlvZCBvYmplY3QgY29udGFpbmluZyBuZWNlc3NhcnkgcGVyaW9kIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyaW9kU3RhcnRcbiAqICAgICAgICBTdGFydCB0aW1lIG9mIHRoZSBQZXJpb2Qgd2l0aGluIHRoZSBtcGRcbiAqIEByZXR1cm4ge1JlcHJlc2VudGF0aW9uSW5mb3JtYXRpb25bXX1cbiAqICAgICAgICAgTGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgUmVwcmVzZW50YWlvbiBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGNhbGxiYWNrIGZvciBBcnJheS5wcm90b3R5cGUubWFwIGZvciBtYXBwaW5nIFBlcmlvZCBub2RlcyB0byBhIGxpc3Qgb2ZcbiAqIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uIG9iamVjdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbXBkQXR0cmlidXRlc1xuICogICAgICAgIENvbnRhaW5zIGF0dHJpYnV0ZXMgaW5oZXJpdGVkIGJ5IHRoZSBtcGRcbiAgKiBAcGFyYW0ge09iamVjdFtdfSBtcGRCYXNlVXJsc1xuICogICAgICAgIENvbnRhaW5zIGxpc3Qgb2Ygb2JqZWN0cyB3aXRoIHJlc29sdmVkIGJhc2UgdXJscyBhbmQgYXR0cmlidXRlc1xuICogICAgICAgIGluaGVyaXRlZCBieSB0aGUgbXBkXG4gKiBAcmV0dXJuIHt0b0FkYXB0YXRpb25TZXRzQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIG1hcCBmdW5jdGlvblxuICovXG5cbmNvbnN0IHRvQWRhcHRhdGlvblNldHMgPSAobXBkQXR0cmlidXRlcywgbXBkQmFzZVVybHMpID0+IChwZXJpb2QsIGluZGV4KSA9PiB7XG4gIGNvbnN0IHBlcmlvZEJhc2VVcmxzID0gYnVpbGRCYXNlVXJscyhtcGRCYXNlVXJscywgZmluZENoaWxkcmVuKHBlcmlvZC5ub2RlLCAnQmFzZVVSTCcpKTtcbiAgY29uc3QgcGVyaW9kQXR0cmlidXRlcyA9IG1lcmdlKG1wZEF0dHJpYnV0ZXMsIHtcbiAgICBwZXJpb2RTdGFydDogcGVyaW9kLmF0dHJpYnV0ZXMuc3RhcnRcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBwZXJpb2QuYXR0cmlidXRlcy5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICBwZXJpb2RBdHRyaWJ1dGVzLnBlcmlvZER1cmF0aW9uID0gcGVyaW9kLmF0dHJpYnV0ZXMuZHVyYXRpb247XG4gIH1cblxuICBjb25zdCBhZGFwdGF0aW9uU2V0cyA9IGZpbmRDaGlsZHJlbihwZXJpb2Qubm9kZSwgJ0FkYXB0YXRpb25TZXQnKTtcbiAgY29uc3QgcGVyaW9kU2VnbWVudEluZm8gPSBnZXRTZWdtZW50SW5mb3JtYXRpb24ocGVyaW9kLm5vZGUpO1xuICByZXR1cm4gZmxhdHRlbihhZGFwdGF0aW9uU2V0cy5tYXAodG9SZXByZXNlbnRhdGlvbnMocGVyaW9kQXR0cmlidXRlcywgcGVyaW9kQmFzZVVybHMsIHBlcmlvZFNlZ21lbnRJbmZvKSkpO1xufTtcbi8qKlxuICogVHJhbmZvcm1zIGFuIGFycmF5IG9mIGNvbnRlbnQgc3RlZXJpbmcgbm9kZXMgaW50byBhbiBvYmplY3RcbiAqIGNvbnRhaW5pbmcgQ0ROIGNvbnRlbnQgc3RlZXJpbmcgaW5mb3JtYXRpb24gZnJvbSB0aGUgTVBEIG1hbmlmZXN0LlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBEQVNIIHNwZWMgZm9yIENvbnRlbnQgU3RlZXJpbmcgcGFyc2luZywgc2VlOlxuICogaHR0cHM6Ly9kYXNoaWYub3JnL2RvY3MvREFTSC1JRi1DVFMtMDBYWC1Db250ZW50LVN0ZWVyaW5nLUNvbW11bml0eS1SZXZpZXcucGRmXG4gKlxuICogQHBhcmFtIHtOb2RlW119IGNvbnRlbnRTdGVlcmluZ05vZGVzXG4gKiAgICAgICAgQ29udGVudCBzdGVlcmluZyBub2Rlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyXG4gKiAgICAgICAgVGhlIGV2ZW50IGhhbmRsZXIgcGFzc2VkIGludG8gdGhlIHBhcnNlciBvcHRpb25zIHRvIGhhbmRsZSB3YXJuaW5nc1xuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIGNvbnRlbnQgc3RlZXJpbmcgZGF0YVxuICovXG5cbmNvbnN0IGdlbmVyYXRlQ29udGVudFN0ZWVyaW5nSW5mb3JtYXRpb24gPSAoY29udGVudFN0ZWVyaW5nTm9kZXMsIGV2ZW50SGFuZGxlcikgPT4ge1xuICAvLyBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBDb250ZW50U3RlZXJpbmcgdGFncywgdGhyb3cgYW4gZXJyb3JcbiAgaWYgKGNvbnRlbnRTdGVlcmluZ05vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICBldmVudEhhbmRsZXIoe1xuICAgICAgdHlwZTogJ3dhcm4nLFxuICAgICAgbWVzc2FnZTogJ1RoZSBNUEQgbWFuaWZlc3Qgc2hvdWxkIGNvbnRhaW4gbm8gbW9yZSB0aGFuIG9uZSBDb250ZW50U3RlZXJpbmcgdGFnJ1xuICAgIH0pO1xuICB9IC8vIFJldHVybiBhIG51bGwgdmFsdWUgaWYgdGhlcmUgYXJlIG5vIENvbnRlbnRTdGVlcmluZyB0YWdzXG5cblxuICBpZiAoIWNvbnRlbnRTdGVlcmluZ05vZGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgaW5mb0Zyb21Db250ZW50U3RlZXJpbmdUYWcgPSBtZXJnZSh7XG4gICAgc2VydmVyVVJMOiBnZXRDb250ZW50KGNvbnRlbnRTdGVlcmluZ05vZGVzWzBdKVxuICB9LCBwYXJzZUF0dHJpYnV0ZXMoY29udGVudFN0ZWVyaW5nTm9kZXNbMF0pKTsgLy8gQ29udmVydHMgYHF1ZXJ5QmVmb3JlU3RhcnRgIHRvIGEgYm9vbGVhbiwgYXMgd2VsbCBhcyBzZXR0aW5nIHRoZSBkZWZhdWx0IHZhbHVlXG4gIC8vIHRvIGBmYWxzZWAgaWYgaXQgZG9lc24ndCBleGlzdFxuXG4gIGluZm9Gcm9tQ29udGVudFN0ZWVyaW5nVGFnLnF1ZXJ5QmVmb3JlU3RhcnQgPSBpbmZvRnJvbUNvbnRlbnRTdGVlcmluZ1RhZy5xdWVyeUJlZm9yZVN0YXJ0ID09PSAndHJ1ZSc7XG4gIHJldHVybiBpbmZvRnJvbUNvbnRlbnRTdGVlcmluZ1RhZztcbn07XG4vKipcbiAqIEdldHMgUGVyaW9kQHN0YXJ0IHByb3BlcnR5IGZvciBhIGdpdmVuIHBlcmlvZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hdHRyaWJ1dGVzXG4gKiAgICAgICAgUGVyaW9kIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wcmlvclBlcmlvZEF0dHJpYnV0ZXNdXG4gKiAgICAgICAgUHJpb3IgcGVyaW9kIGF0dHJpYnV0ZXMgKGlmIHByaW9yIHBlcmlvZCBpcyBhdmFpbGFibGUpXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tcGRUeXBlXG4gKiAgICAgICAgVGhlIE1QREB0eXBlIHRoZXNlIHBlcmlvZHMgY2FtZSBmcm9tXG4gKiBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAqICAgICAgICAgVGhlIHBlcmlvZCBzdGFydCwgb3IgbnVsbCBpZiBpdCdzIGFuIGVhcmx5IGF2YWlsYWJsZSBwZXJpb2Qgb3IgZXJyb3JcbiAqL1xuXG5jb25zdCBnZXRQZXJpb2RTdGFydCA9ICh7XG4gIGF0dHJpYnV0ZXMsXG4gIHByaW9yUGVyaW9kQXR0cmlidXRlcyxcbiAgbXBkVHlwZVxufSkgPT4ge1xuICAvLyBTdW1tYXJ5IG9mIHBlcmlvZCBzdGFydCB0aW1lIGNhbGN1bGF0aW9uIGZyb20gREFTSCBzcGVjIHNlY3Rpb24gNS4zLjIuMVxuICAvL1xuICAvLyBBIHBlcmlvZCdzIHN0YXJ0IGlzIHRoZSBmaXJzdCBwZXJpb2QncyBzdGFydCArIHRpbWUgZWxhcHNlZCBhZnRlciBwbGF5aW5nIGFsbFxuICAvLyBwcmlvciBwZXJpb2RzIHRvIHRoaXMgb25lLiBQZXJpb2RzIGNvbnRpbnVlIG9uZSBhZnRlciB0aGUgb3RoZXIgaW4gdGltZSAod2l0aG91dFxuICAvLyBnYXBzKSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwcmVzZW50YXRpb24uXG4gIC8vXG4gIC8vIFRoZSB2YWx1ZSBvZiBQZXJpb2RAc3RhcnQgc2hvdWxkIGJlOlxuICAvLyAxLiBpZiBQZXJpb2RAc3RhcnQgaXMgcHJlc2VudDogdmFsdWUgb2YgUGVyaW9kQHN0YXJ0XG4gIC8vIDIuIGlmIHByZXZpb3VzIHBlcmlvZCBleGlzdHMgYW5kIGl0IGhhcyBAZHVyYXRpb246IHByZXZpb3VzIFBlcmlvZEBzdGFydCArXG4gIC8vICAgIHByZXZpb3VzIFBlcmlvZEBkdXJhdGlvblxuICAvLyAzLiBpZiB0aGlzIGlzIGZpcnN0IHBlcmlvZCBhbmQgTVBEQHR5cGUgaXMgJ3N0YXRpYyc6IDBcbiAgLy8gNC4gaW4gYWxsIG90aGVyIGNhc2VzLCBjb25zaWRlciB0aGUgcGVyaW9kIGFuIFwiZWFybHkgYXZhaWxhYmxlIHBlcmlvZFwiIChub3RlOiBub3RcbiAgLy8gICAgY3VycmVudGx5IHN1cHBvcnRlZClcbiAgLy8gKDEpXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5zdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcy5zdGFydDtcbiAgfSAvLyAoMilcblxuXG4gIGlmIChwcmlvclBlcmlvZEF0dHJpYnV0ZXMgJiYgdHlwZW9mIHByaW9yUGVyaW9kQXR0cmlidXRlcy5zdGFydCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHByaW9yUGVyaW9kQXR0cmlidXRlcy5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gcHJpb3JQZXJpb2RBdHRyaWJ1dGVzLnN0YXJ0ICsgcHJpb3JQZXJpb2RBdHRyaWJ1dGVzLmR1cmF0aW9uO1xuICB9IC8vICgzKVxuXG5cbiAgaWYgKCFwcmlvclBlcmlvZEF0dHJpYnV0ZXMgJiYgbXBkVHlwZSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyAoNClcbiAgLy8gVGhlcmUgaXMgY3VycmVudGx5IG5vIGxvZ2ljIGZvciBjYWxjdWxhdGluZyB0aGUgUGVyaW9kQHN0YXJ0IHZhbHVlIGlmIHRoZXJlIGlzXG4gIC8vIG5vIFBlcmlvZEBzdGFydCBvciBwcmlvciBQZXJpb2RAc3RhcnQgYW5kIFBlcmlvZEBkdXJhdGlvbiBhdmFpbGFibGUuIFRoaXMgaXMgbm90IG1hZGVcbiAgLy8gZXhwbGljaXQgYnkgdGhlIERBU0ggaW50ZXJvcCBndWlkZWxpbmVzIG9yIHRoZSBEQVNIIHNwZWMsIGhvd2V2ZXIsIHNpbmNlIHRoZXJlJ3NcbiAgLy8gbm90aGluZyBhYm91dCBhbnkgb3RoZXIgcmVzb2x1dGlvbiBzdHJhdGVnaWVzLCBpdCdzIGltcGxpZWQuIFRodXMsIHRoaXMgY2FzZSBzaG91bGRcbiAgLy8gYmUgY29uc2lkZXJlZCBhbiBlYXJseSBhdmFpbGFibGUgcGVyaW9kLCBvciBlcnJvciwgYW5kIG51bGwgc2hvdWxkIHN1ZmZpY2UgZm9yIGJvdGhcbiAgLy8gb2YgdGhvc2UgY2FzZXMuXG5cblxuICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgbXBkIHhtbCB0cmVlIHRvIGdlbmVyYXRlIGEgbGlzdCBvZiBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBvYmplY3RzXG4gKiB0aGF0IGhhdmUgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgbm9kZXNcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG1wZFxuICogICAgICAgIFRoZSByb290IG5vZGUgb2YgdGhlIG1wZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBBdmFpbGFibGUgb3B0aW9ucyBmb3IgaW5oZXJpdEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1hbmlmZXN0VXJpXG4gKiAgICAgICAgVGhlIHVyaSBzb3VyY2Ugb2YgdGhlIG1wZFxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuTk9XXG4gKiAgICAgICAgQ3VycmVudCB0aW1lIHBlciBEQVNIIElPUC4gIERlZmF1bHQgaXMgY3VycmVudCB0aW1lIGluIG1zIHNpbmNlIGVwb2NoXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jbGllbnRPZmZzZXRcbiAqICAgICAgICBDbGllbnQgdGltZSBkaWZmZXJlbmNlIGZyb20gTk9XIChpbiBtaWxsaXNlY29uZHMpXG4gKiBAcmV0dXJuIHtSZXByZXNlbnRhdGlvbkluZm9ybWF0aW9uW119XG4gKiAgICAgICAgIExpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uXG4gKi9cblxuY29uc3QgaW5oZXJpdEF0dHJpYnV0ZXMgPSAobXBkLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIG1hbmlmZXN0VXJpID0gJycsXG4gICAgTk9XID0gRGF0ZS5ub3coKSxcbiAgICBjbGllbnRPZmZzZXQgPSAwLFxuICAgIC8vIFRPRE86IEZvciBub3csIHdlIGFyZSBleHBlY3RpbmcgYW4gZXZlbnRIYW5kbGVyIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgLy8gdG8gYmUgcGFzc2VkIGludG8gdGhlIG1wZCBwYXJzZXIgYXMgYW4gb3B0aW9uLlxuICAgIC8vIEluIHRoZSBmdXR1cmUsIHdlIHNob3VsZCBlbmFibGUgc3RyZWFtIHBhcnNpbmcgYnkgdXNpbmcgdGhlIFN0cmVhbSBjbGFzcyBmcm9tIHZocy11dGlscy5cbiAgICAvLyBUaGlzIHdpbGwgc3VwcG9ydCBuZXcgZmVhdHVyZXMgaW5jbHVkaW5nIGEgc3RhbmRhcmRpemVkIGV2ZW50IGhhbmRsZXIuXG4gICAgLy8gU2VlIHRoZSBtM3U4IHBhcnNlciBmb3IgZXhhbXBsZXMgb2YgaG93IHN0cmVhbSBwYXJzaW5nIGlzIGN1cnJlbnRseSB1c2VkIGZvciBITFMgcGFyc2luZy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aHMtdXRpbHMvYmxvYi84OGQ2ZTEwYzYzMWU1N2E1YWYwMmM1YTYyYmM3Mzc2Y2Q0NTZiNGY1L3NyYy9zdHJlYW0uanMjTDlcbiAgICBldmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7fVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGVyaW9kTm9kZXMgPSBmaW5kQ2hpbGRyZW4obXBkLCAnUGVyaW9kJyk7XG5cbiAgaWYgKCFwZXJpb2ROb2Rlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklOVkFMSURfTlVNQkVSX09GX1BFUklPRCk7XG4gIH1cblxuICBjb25zdCBsb2NhdGlvbnMgPSBmaW5kQ2hpbGRyZW4obXBkLCAnTG9jYXRpb24nKTtcbiAgY29uc3QgbXBkQXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtcGQpO1xuICBjb25zdCBtcGRCYXNlVXJscyA9IGJ1aWxkQmFzZVVybHMoW3tcbiAgICBiYXNlVXJsOiBtYW5pZmVzdFVyaVxuICB9XSwgZmluZENoaWxkcmVuKG1wZCwgJ0Jhc2VVUkwnKSk7XG4gIGNvbnN0IGNvbnRlbnRTdGVlcmluZ05vZGVzID0gZmluZENoaWxkcmVuKG1wZCwgJ0NvbnRlbnRTdGVlcmluZycpOyAvLyBTZWUgREFTSCBzcGVjIHNlY3Rpb24gNS4zLjEuMiwgU2VtYW50aWNzIG9mIE1QRCBlbGVtZW50LiBEZWZhdWx0IHR5cGUgdG8gJ3N0YXRpYycuXG5cbiAgbXBkQXR0cmlidXRlcy50eXBlID0gbXBkQXR0cmlidXRlcy50eXBlIHx8ICdzdGF0aWMnO1xuICBtcGRBdHRyaWJ1dGVzLnNvdXJjZUR1cmF0aW9uID0gbXBkQXR0cmlidXRlcy5tZWRpYVByZXNlbnRhdGlvbkR1cmF0aW9uIHx8IDA7XG4gIG1wZEF0dHJpYnV0ZXMuTk9XID0gTk9XO1xuICBtcGRBdHRyaWJ1dGVzLmNsaWVudE9mZnNldCA9IGNsaWVudE9mZnNldDtcblxuICBpZiAobG9jYXRpb25zLmxlbmd0aCkge1xuICAgIG1wZEF0dHJpYnV0ZXMubG9jYXRpb25zID0gbG9jYXRpb25zLm1hcChnZXRDb250ZW50KTtcbiAgfVxuXG4gIGNvbnN0IHBlcmlvZHMgPSBbXTsgLy8gU2luY2UgdG9BZGFwdGF0aW9uU2V0cyBhY3RzIG9uIGluZGl2aWR1YWwgcGVyaW9kcyByaWdodCBub3csIHRoZSBzaW1wbGVzdCBhcHByb2FjaCB0b1xuICAvLyBhZGRpbmcgcHJvcGVydGllcyB0aGF0IHJlcXVpcmUgbG9va2luZyBhdCBwcmlvciBwZXJpb2RzIGlzIHRvIHBhcnNlIGF0dHJpYnV0ZXMgYW5kIGFkZFxuICAvLyBtaXNzaW5nIG9uZXMgYmVmb3JlIHRvQWRhcHRhdGlvblNldHMgaXMgY2FsbGVkLiBJZiBtb3JlIHN1Y2ggcHJvcGVydGllcyBhcmUgYWRkZWQsIGl0XG4gIC8vIG1heSBiZSBiZXR0ZXIgdG8gcmVmYWN0b3IgdG9BZGFwdGF0aW9uU2V0cy5cblxuICBwZXJpb2ROb2Rlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobm9kZSk7IC8vIFVzZSB0aGUgbGFzdCBtb2RpZmllZCBwcmlvciBwZXJpb2QsIGFzIGl0IG1heSBjb250YWluIGFkZGVkIGluZm9ybWF0aW9uIG5lY2Vzc2FyeVxuICAgIC8vIGZvciB0aGlzIHBlcmlvZC5cblxuICAgIGNvbnN0IHByaW9yUGVyaW9kID0gcGVyaW9kc1tpbmRleCAtIDFdO1xuICAgIGF0dHJpYnV0ZXMuc3RhcnQgPSBnZXRQZXJpb2RTdGFydCh7XG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgcHJpb3JQZXJpb2RBdHRyaWJ1dGVzOiBwcmlvclBlcmlvZCA/IHByaW9yUGVyaW9kLmF0dHJpYnV0ZXMgOiBudWxsLFxuICAgICAgbXBkVHlwZTogbXBkQXR0cmlidXRlcy50eXBlXG4gICAgfSk7XG4gICAgcGVyaW9kcy5wdXNoKHtcbiAgICAgIG5vZGUsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGxvY2F0aW9uczogbXBkQXR0cmlidXRlcy5sb2NhdGlvbnMsXG4gICAgY29udGVudFN0ZWVyaW5nSW5mbzogZ2VuZXJhdGVDb250ZW50U3RlZXJpbmdJbmZvcm1hdGlvbihjb250ZW50U3RlZXJpbmdOb2RlcywgZXZlbnRIYW5kbGVyKSxcbiAgICAvLyBUT0RPOiBUaGVyZSBhcmUgb2NjdXJlbmNlcyB3aGVyZSB0aGlzIGByZXByZXNlbnRhdGlvbkluZm9gIGFycmF5IGNvbnRhaW5zIHVuZGVzaXJlZFxuICAgIC8vIGR1cGxpY2F0ZXMuIFRoaXMgZ2VuZXJhbGx5IG9jY3VycyB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBCYXNlVVJMIG5vZGVzIHRoYXQgYXJlXG4gICAgLy8gZGlyZWN0IGNoaWxkcmVuIG9mIHRoZSBNUEQgbm9kZS4gV2hlbiB3ZSBhdHRlbXB0IHRvIHJlc29sdmUgVVJMcyBmcm9tIGEgY29tYmluYXRpb24gb2YgdGhlXG4gICAgLy8gcGFyZW50IEJhc2VVUkwgYW5kIGEgY2hpbGQgQmFzZVVSTCwgYW5kIHRoZSB2YWx1ZSBkb2VzIG5vdCByZXNvbHZlLFxuICAgIC8vIHdlIGVuZCB1cCByZXR1cm5pbmcgdGhlIGNoaWxkIEJhc2VVUkwgbXVsdGlwbGUgdGltZXMuXG4gICAgLy8gV2UgbmVlZCB0byBkZXRlcm1pbmUgYSB3YXkgdG8gcmVtb3ZlIHRoZXNlIGR1cGxpY2F0ZXMgaW4gYSBzYWZlIHdheS5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL21wZC1wYXJzZXIvcHVsbC8xNyNkaXNjdXNzaW9uX3IxNjI3NTA1MjdcbiAgICByZXByZXNlbnRhdGlvbkluZm86IGZsYXR0ZW4ocGVyaW9kcy5tYXAodG9BZGFwdGF0aW9uU2V0cyhtcGRBdHRyaWJ1dGVzLCBtcGRCYXNlVXJscykpKSxcbiAgICBldmVudFN0cmVhbTogZmxhdHRlbihwZXJpb2RzLm1hcCh0b0V2ZW50U3RyZWFtKSlcbiAgfTtcbn07XG5cbmNvbnN0IHN0cmluZ1RvTXBkWG1sID0gbWFuaWZlc3RTdHJpbmcgPT4ge1xuICBpZiAobWFuaWZlc3RTdHJpbmcgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5EQVNIX0VNUFRZX01BTklGRVNUKTtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgbGV0IHhtbDtcbiAgbGV0IG1wZDtcblxuICB0cnkge1xuICAgIHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcobWFuaWZlc3RTdHJpbmcsICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICBtcGQgPSB4bWwgJiYgeG1sLmRvY3VtZW50RWxlbWVudC50YWdOYW1lID09PSAnTVBEJyA/IHhtbC5kb2N1bWVudEVsZW1lbnQgOiBudWxsO1xuICB9IGNhdGNoIChlKSB7Ly8gaWUgMTEgdGhyb3dzIG9uIGludmFsaWQgeG1sXG4gIH1cblxuICBpZiAoIW1wZCB8fCBtcGQgJiYgbXBkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkRBU0hfSU5WQUxJRF9YTUwpO1xuICB9XG5cbiAgcmV0dXJuIG1wZDtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBtYW5pZmVzdCBmb3IgYSBVVENUaW1pbmcgbm9kZSwgcmV0dXJuaW5nIHRoZSBub2RlcyBhdHRyaWJ1dGVzIGlmIGZvdW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1wZFxuICogICAgICAgIFhNTCBzdHJpbmcgb2YgdGhlIE1QRCBtYW5pZmVzdFxuICogQHJldHVybiB7T2JqZWN0fG51bGx9XG4gKiAgICAgICAgIEF0dHJpYnV0ZXMgb2YgVVRDVGltaW5nIG5vZGUgc3BlY2lmaWVkIGluIHRoZSBtYW5pZmVzdC4gTnVsbCBpZiBub25lIGZvdW5kXG4gKi9cblxuY29uc3QgcGFyc2VVVENUaW1pbmdTY2hlbWUgPSBtcGQgPT4ge1xuICBjb25zdCBVVENUaW1pbmdOb2RlID0gZmluZENoaWxkcmVuKG1wZCwgJ1VUQ1RpbWluZycpWzBdO1xuXG4gIGlmICghVVRDVGltaW5nTm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhVVENUaW1pbmdOb2RlKTtcblxuICBzd2l0Y2ggKGF0dHJpYnV0ZXMuc2NoZW1lSWRVcmkpIHtcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpodHRwLWhlYWQ6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC1oZWFkOjIwMTInOlxuICAgICAgYXR0cmlidXRlcy5tZXRob2QgPSAnSEVBRCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAteHNkYXRlOjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAtaXNvOjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAteHNkYXRlOjIwMTInOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAtaXNvOjIwMTInOlxuICAgICAgYXR0cmlidXRlcy5tZXRob2QgPSAnR0VUJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6ZGlyZWN0OjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmRpcmVjdDoyMDEyJzpcbiAgICAgIGF0dHJpYnV0ZXMubWV0aG9kID0gJ0RJUkVDVCc7XG4gICAgICBhdHRyaWJ1dGVzLnZhbHVlID0gRGF0ZS5wYXJzZShhdHRyaWJ1dGVzLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC1udHA6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6bnRwOjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOnNudHA6MjAxNCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVU5TVVBQT1JURURfVVRDX1RJTUlOR19TQ0hFTUUpO1xuICB9XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59O1xuXG5jb25zdCBWRVJTSU9OID0gdmVyc2lvbjtcbi8qXG4gKiBHaXZlbiBhIERBU0ggbWFuaWZlc3Qgc3RyaW5nIGFuZCBvcHRpb25zLCBwYXJzZXMgdGhlIERBU0ggbWFuaWZlc3QgaW50byBhbiBvYmplY3QgaW4gdGhlXG4gKiBmb3JtIG91dHB1dGVkIGJ5IG0zdTgtcGFyc2VyIGFuZCBhY2NlcHRlZCBieSB2aWRlb2pzL2h0dHAtc3RyZWFtaW5nLlxuICpcbiAqIEZvciBsaXZlIERBU0ggbWFuaWZlc3RzLCBpZiBgcHJldmlvdXNNYW5pZmVzdGAgaXMgcHJvdmlkZWQgaW4gb3B0aW9ucywgdGhlbiB0aGUgbmV3bHlcbiAqIHBhcnNlZCBEQVNIIG1hbmlmZXN0IHdpbGwgaGF2ZSBpdHMgbWVkaWEgc2VxdWVuY2UgYW5kIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdmFsdWVzXG4gKiB1cGRhdGVkIHRvIHJlZmxlY3QgaXRzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwcmlvciBtYW5pZmVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFuaWZlc3RTdHJpbmcgLSB0aGUgREFTSCBtYW5pZmVzdCBhcyBhIHN0cmluZ1xuICogQHBhcmFtIHtvcHRpb25zfSBbb3B0aW9uc10gLSBhbnkgb3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG1hbmlmZXN0IG9iamVjdFxuICovXG5cbmNvbnN0IHBhcnNlID0gKG1hbmlmZXN0U3RyaW5nLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgcGFyc2VkTWFuaWZlc3RJbmZvID0gaW5oZXJpdEF0dHJpYnV0ZXMoc3RyaW5nVG9NcGRYbWwobWFuaWZlc3RTdHJpbmcpLCBvcHRpb25zKTtcbiAgY29uc3QgcGxheWxpc3RzID0gdG9QbGF5bGlzdHMocGFyc2VkTWFuaWZlc3RJbmZvLnJlcHJlc2VudGF0aW9uSW5mbyk7XG4gIHJldHVybiB0b00zdTgoe1xuICAgIGRhc2hQbGF5bGlzdHM6IHBsYXlsaXN0cyxcbiAgICBsb2NhdGlvbnM6IHBhcnNlZE1hbmlmZXN0SW5mby5sb2NhdGlvbnMsXG4gICAgY29udGVudFN0ZWVyaW5nOiBwYXJzZWRNYW5pZmVzdEluZm8uY29udGVudFN0ZWVyaW5nSW5mbyxcbiAgICBzaWR4TWFwcGluZzogb3B0aW9ucy5zaWR4TWFwcGluZyxcbiAgICBwcmV2aW91c01hbmlmZXN0OiBvcHRpb25zLnByZXZpb3VzTWFuaWZlc3QsXG4gICAgZXZlbnRTdHJlYW06IHBhcnNlZE1hbmlmZXN0SW5mby5ldmVudFN0cmVhbVxuICB9KTtcbn07XG4vKipcbiAqIFBhcnNlcyB0aGUgbWFuaWZlc3QgZm9yIGEgVVRDVGltaW5nIG5vZGUsIHJldHVybmluZyB0aGUgbm9kZXMgYXR0cmlidXRlcyBpZiBmb3VuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYW5pZmVzdFN0cmluZ1xuICogICAgICAgIFhNTCBzdHJpbmcgb2YgdGhlIE1QRCBtYW5pZmVzdFxuICogQHJldHVybiB7T2JqZWN0fG51bGx9XG4gKiAgICAgICAgIEF0dHJpYnV0ZXMgb2YgVVRDVGltaW5nIG5vZGUgc3BlY2lmaWVkIGluIHRoZSBtYW5pZmVzdC4gTnVsbCBpZiBub25lIGZvdW5kXG4gKi9cblxuXG5jb25zdCBwYXJzZVVUQ1RpbWluZyA9IG1hbmlmZXN0U3RyaW5nID0+IHBhcnNlVVRDVGltaW5nU2NoZW1lKHN0cmluZ1RvTXBkWG1sKG1hbmlmZXN0U3RyaW5nKSk7XG5cbmV4cG9ydCB7IFZFUlNJT04sIGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3QkMSBhcyBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0LCBnZW5lcmF0ZVNpZHhLZXksIGluaGVyaXRBdHRyaWJ1dGVzLCBwYXJzZSwgcGFyc2VVVENUaW1pbmcsIHN0cmluZ1RvTXBkWG1sLCB0b00zdTgsIHRvUGxheWxpc3RzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mpd-parser/dist/mpd-parser.es.js\n");

/***/ })

};
;